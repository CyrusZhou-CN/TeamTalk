// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.BaseDefine.proto

#include "IM.BaseDefine.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace IM {
namespace BaseDefine {
PROTOBUF_CONSTEXPR IpAddr::IpAddr(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IpAddrDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IpAddrDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IpAddrDefaultTypeInternal() {}
  union {
    IpAddr _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IpAddrDefaultTypeInternal _IpAddr_default_instance_;
PROTOBUF_CONSTEXPR UserInfo::UserInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_nick_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.avatar_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.email_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_real_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_tel_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_domain_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.user_gender_)*/0u
  , /*decltype(_impl_.department_id_)*/0u
  , /*decltype(_impl_.status_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UserInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserInfoDefaultTypeInternal() {}
  union {
    UserInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserInfoDefaultTypeInternal _UserInfo_default_instance_;
PROTOBUF_CONSTEXPR ContactSessionInfo::ContactSessionInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.latest_msg_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.session_id_)*/0u
  , /*decltype(_impl_.session_type_)*/0
  , /*decltype(_impl_.session_status_)*/0
  , /*decltype(_impl_.updated_time_)*/0u
  , /*decltype(_impl_.latest_msg_id_)*/0u
  , /*decltype(_impl_.latest_msg_type_)*/0
  , /*decltype(_impl_.latest_msg_from_user_id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ContactSessionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContactSessionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContactSessionInfoDefaultTypeInternal() {}
  union {
    ContactSessionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContactSessionInfoDefaultTypeInternal _ContactSessionInfo_default_instance_;
PROTOBUF_CONSTEXPR UserStat::UserStat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UserStatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserStatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserStatDefaultTypeInternal() {}
  union {
    UserStat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserStatDefaultTypeInternal _UserStat_default_instance_;
PROTOBUF_CONSTEXPR ServerUserStat::ServerUserStat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_.client_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ServerUserStatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServerUserStatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServerUserStatDefaultTypeInternal() {}
  union {
    ServerUserStat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerUserStatDefaultTypeInternal _ServerUserStat_default_instance_;
PROTOBUF_CONSTEXPR UnreadInfo::UnreadInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.latest_msg_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.session_id_)*/0u
  , /*decltype(_impl_.session_type_)*/0
  , /*decltype(_impl_.unread_cnt_)*/0u
  , /*decltype(_impl_.latest_msg_id_)*/0u
  , /*decltype(_impl_.latest_msg_type_)*/0
  , /*decltype(_impl_.latest_msg_from_user_id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UnreadInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnreadInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnreadInfoDefaultTypeInternal() {}
  union {
    UnreadInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnreadInfoDefaultTypeInternal _UnreadInfo_default_instance_;
PROTOBUF_CONSTEXPR MsgInfo::MsgInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.msg_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msg_id_)*/0u
  , /*decltype(_impl_.from_session_id_)*/0u
  , /*decltype(_impl_.create_time_)*/0u
  , /*decltype(_impl_.msg_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MsgInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MsgInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MsgInfoDefaultTypeInternal() {}
  union {
    MsgInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MsgInfoDefaultTypeInternal _MsgInfo_default_instance_;
PROTOBUF_CONSTEXPR GroupVersionInfo::GroupVersionInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GroupVersionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupVersionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupVersionInfoDefaultTypeInternal() {}
  union {
    GroupVersionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupVersionInfoDefaultTypeInternal _GroupVersionInfo_default_instance_;
PROTOBUF_CONSTEXPR GroupInfo::GroupInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.group_member_list_)*/{}
  , /*decltype(_impl_._group_member_list_cached_byte_size_)*/{0}
  , /*decltype(_impl_.group_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_avatar_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.group_creator_id_)*/0u
  , /*decltype(_impl_.group_type_)*/0
  , /*decltype(_impl_.shield_status_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GroupInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupInfoDefaultTypeInternal() {}
  union {
    GroupInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupInfoDefaultTypeInternal _GroupInfo_default_instance_;
PROTOBUF_CONSTEXPR UserTokenInfo::UserTokenInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.user_type_)*/0
  , /*decltype(_impl_.push_count_)*/0u
  , /*decltype(_impl_.push_type_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UserTokenInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserTokenInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserTokenInfoDefaultTypeInternal() {}
  union {
    UserTokenInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserTokenInfoDefaultTypeInternal _UserTokenInfo_default_instance_;
PROTOBUF_CONSTEXPR PushResult::PushResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.result_code_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PushResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PushResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PushResultDefaultTypeInternal() {}
  union {
    PushResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PushResultDefaultTypeInternal _PushResult_default_instance_;
PROTOBUF_CONSTEXPR ShieldStatus::ShieldStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.shield_status_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ShieldStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShieldStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShieldStatusDefaultTypeInternal() {}
  union {
    ShieldStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShieldStatusDefaultTypeInternal _ShieldStatus_default_instance_;
PROTOBUF_CONSTEXPR OfflineFileInfo::OfflineFileInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.task_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.from_user_id_)*/0u
  , /*decltype(_impl_.file_size_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OfflineFileInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OfflineFileInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OfflineFileInfoDefaultTypeInternal() {}
  union {
    OfflineFileInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OfflineFileInfoDefaultTypeInternal _OfflineFileInfo_default_instance_;
PROTOBUF_CONSTEXPR AuthInfo::AuthInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.app_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allowd_user_ids_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allowd_group_ids_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.auth_interfaces_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.auth_ips_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AuthInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthInfoDefaultTypeInternal() {}
  union {
    AuthInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthInfoDefaultTypeInternal _AuthInfo_default_instance_;
PROTOBUF_CONSTEXPR DepartInfo::DepartInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dept_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dept_id_)*/0u
  , /*decltype(_impl_.priority_)*/0u
  , /*decltype(_impl_.parent_dept_id_)*/0u
  , /*decltype(_impl_.dept_status_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DepartInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DepartInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DepartInfoDefaultTypeInternal() {}
  union {
    DepartInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DepartInfoDefaultTypeInternal _DepartInfo_default_instance_;
}  // namespace BaseDefine
}  // namespace IM
namespace IM {
namespace BaseDefine {
bool ServiceID_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceID_strings[9] = {};

static const char ServiceID_names[] =
  "SID_BUDDY_LIST"
  "SID_FILE"
  "SID_GROUP"
  "SID_INTERNAL"
  "SID_LOGIN"
  "SID_MSG"
  "SID_NONE"
  "SID_OTHER"
  "SID_SWITCH_SERVICE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceID_entries[] = {
  { {ServiceID_names + 0, 14}, 2 },
  { {ServiceID_names + 14, 8}, 5 },
  { {ServiceID_names + 22, 9}, 4 },
  { {ServiceID_names + 31, 12}, 8 },
  { {ServiceID_names + 43, 9}, 1 },
  { {ServiceID_names + 52, 7}, 3 },
  { {ServiceID_names + 59, 8}, 0 },
  { {ServiceID_names + 67, 9}, 7 },
  { {ServiceID_names + 76, 18}, 6 },
};

static const int ServiceID_entries_by_number[] = {
  6, // 0 -> SID_NONE
  4, // 1 -> SID_LOGIN
  0, // 2 -> SID_BUDDY_LIST
  5, // 3 -> SID_MSG
  2, // 4 -> SID_GROUP
  1, // 5 -> SID_FILE
  8, // 6 -> SID_SWITCH_SERVICE
  7, // 7 -> SID_OTHER
  3, // 8 -> SID_INTERNAL
};

const std::string& ServiceID_Name(
    ServiceID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServiceID_entries,
          ServiceID_entries_by_number,
          9, ServiceID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServiceID_entries,
      ServiceID_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServiceID_strings[idx].get();
}
bool ServiceID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServiceID_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<ServiceID>(int_value);
  }
  return success;
}
bool InternalCmdID_IsValid(int value) {
  switch (value) {
    case 0:
    case 2049:
    case 2050:
    case 2051:
    case 2052:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> InternalCmdID_strings[5] = {};

static const char InternalCmdID_names[] =
  "CID_INTERNAL_NONE"
  "CID_INTERNAL_SYNC_AUTH_INFO_REQ"
  "CID_INTERNAL_SYNC_AUTH_INFO_RSP"
  "CID_INTERNAL_USER_ID_BY_NICK_NAME_REQ"
  "CID_INTERNAL_USER_ID_BY_NICK_NAME_RSP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry InternalCmdID_entries[] = {
  { {InternalCmdID_names + 0, 17}, 0 },
  { {InternalCmdID_names + 17, 31}, 2049 },
  { {InternalCmdID_names + 48, 31}, 2050 },
  { {InternalCmdID_names + 79, 37}, 2051 },
  { {InternalCmdID_names + 116, 37}, 2052 },
};

static const int InternalCmdID_entries_by_number[] = {
  0, // 0 -> CID_INTERNAL_NONE
  1, // 2049 -> CID_INTERNAL_SYNC_AUTH_INFO_REQ
  2, // 2050 -> CID_INTERNAL_SYNC_AUTH_INFO_RSP
  3, // 2051 -> CID_INTERNAL_USER_ID_BY_NICK_NAME_REQ
  4, // 2052 -> CID_INTERNAL_USER_ID_BY_NICK_NAME_RSP
};

const std::string& InternalCmdID_Name(
    InternalCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          InternalCmdID_entries,
          InternalCmdID_entries_by_number,
          5, InternalCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      InternalCmdID_entries,
      InternalCmdID_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     InternalCmdID_strings[idx].get();
}
bool InternalCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InternalCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      InternalCmdID_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<InternalCmdID>(int_value);
  }
  return success;
}
bool LoginCmdID_IsValid(int value) {
  switch (value) {
    case 0:
    case 257:
    case 258:
    case 259:
    case 260:
    case 261:
    case 262:
    case 263:
    case 264:
    case 265:
    case 266:
    case 267:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginCmdID_strings[12] = {};

static const char LoginCmdID_names[] =
  "CID_LOGIN_KICK_USER"
  "CID_LOGIN_NONE"
  "CID_LOGIN_REQ_DEVICETOKEN"
  "CID_LOGIN_REQ_KICKPCCLIENT"
  "CID_LOGIN_REQ_LOGINOUT"
  "CID_LOGIN_REQ_MSGSERVER"
  "CID_LOGIN_REQ_USERLOGIN"
  "CID_LOGIN_RES_DEVICETOKEN"
  "CID_LOGIN_RES_KICKPCCLIENT"
  "CID_LOGIN_RES_LOGINOUT"
  "CID_LOGIN_RES_MSGSERVER"
  "CID_LOGIN_RES_USERLOGIN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginCmdID_entries[] = {
  { {LoginCmdID_names + 0, 19}, 263 },
  { {LoginCmdID_names + 19, 14}, 0 },
  { {LoginCmdID_names + 33, 25}, 264 },
  { {LoginCmdID_names + 58, 26}, 266 },
  { {LoginCmdID_names + 84, 22}, 261 },
  { {LoginCmdID_names + 106, 23}, 257 },
  { {LoginCmdID_names + 129, 23}, 259 },
  { {LoginCmdID_names + 152, 25}, 265 },
  { {LoginCmdID_names + 177, 26}, 267 },
  { {LoginCmdID_names + 203, 22}, 262 },
  { {LoginCmdID_names + 225, 23}, 258 },
  { {LoginCmdID_names + 248, 23}, 260 },
};

static const int LoginCmdID_entries_by_number[] = {
  1, // 0 -> CID_LOGIN_NONE
  5, // 257 -> CID_LOGIN_REQ_MSGSERVER
  10, // 258 -> CID_LOGIN_RES_MSGSERVER
  6, // 259 -> CID_LOGIN_REQ_USERLOGIN
  11, // 260 -> CID_LOGIN_RES_USERLOGIN
  4, // 261 -> CID_LOGIN_REQ_LOGINOUT
  9, // 262 -> CID_LOGIN_RES_LOGINOUT
  0, // 263 -> CID_LOGIN_KICK_USER
  2, // 264 -> CID_LOGIN_REQ_DEVICETOKEN
  7, // 265 -> CID_LOGIN_RES_DEVICETOKEN
  3, // 266 -> CID_LOGIN_REQ_KICKPCCLIENT
  8, // 267 -> CID_LOGIN_RES_KICKPCCLIENT
};

const std::string& LoginCmdID_Name(
    LoginCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LoginCmdID_entries,
          LoginCmdID_entries_by_number,
          12, LoginCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LoginCmdID_entries,
      LoginCmdID_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LoginCmdID_strings[idx].get();
}
bool LoginCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LoginCmdID_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<LoginCmdID>(int_value);
  }
  return success;
}
bool BuddyListCmdID_IsValid(int value) {
  switch (value) {
    case 0:
    case 513:
    case 514:
    case 515:
    case 516:
    case 517:
    case 518:
    case 519:
    case 520:
    case 521:
    case 522:
    case 523:
    case 524:
    case 525:
    case 526:
    case 527:
    case 528:
    case 529:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BuddyListCmdID_strings[18] = {};

static const char BuddyListCmdID_names[] =
  "CID_BUDDY_LIST_ALL_USER_REQUEST"
  "CID_BUDDY_LIST_ALL_USER_RESPONSE"
  "CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST"
  "CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE"
  "CID_BUDDY_LIST_DEPARTMENT_REQUEST"
  "CID_BUDDY_LIST_DEPARTMENT_RESPONSE"
  "CID_BUDDY_LIST_NONE"
  "CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY"
  "CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST"
  "CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE"
  "CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY"
  "CID_BUDDY_LIST_REMOVE_SESSION_REQ"
  "CID_BUDDY_LIST_REMOVE_SESSION_RES"
  "CID_BUDDY_LIST_STATUS_NOTIFY"
  "CID_BUDDY_LIST_USERS_STATUS_REQUEST"
  "CID_BUDDY_LIST_USERS_STATUS_RESPONSE"
  "CID_BUDDY_LIST_USER_INFO_REQUEST"
  "CID_BUDDY_LIST_USER_INFO_RESPONSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BuddyListCmdID_entries[] = {
  { {BuddyListCmdID_names + 0, 31}, 520 },
  { {BuddyListCmdID_names + 31, 32}, 521 },
  { {BuddyListCmdID_names + 63, 36}, 524 },
  { {BuddyListCmdID_names + 99, 37}, 525 },
  { {BuddyListCmdID_names + 136, 33}, 528 },
  { {BuddyListCmdID_names + 169, 34}, 529 },
  { {BuddyListCmdID_names + 203, 19}, 0 },
  { {BuddyListCmdID_names + 222, 37}, 526 },
  { {BuddyListCmdID_names + 259, 45}, 513 },
  { {BuddyListCmdID_names + 304, 46}, 514 },
  { {BuddyListCmdID_names + 350, 36}, 527 },
  { {BuddyListCmdID_names + 386, 33}, 518 },
  { {BuddyListCmdID_names + 419, 33}, 519 },
  { {BuddyListCmdID_names + 452, 28}, 515 },
  { {BuddyListCmdID_names + 480, 35}, 522 },
  { {BuddyListCmdID_names + 515, 36}, 523 },
  { {BuddyListCmdID_names + 551, 32}, 516 },
  { {BuddyListCmdID_names + 583, 33}, 517 },
};

static const int BuddyListCmdID_entries_by_number[] = {
  6, // 0 -> CID_BUDDY_LIST_NONE
  8, // 513 -> CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST
  9, // 514 -> CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE
  13, // 515 -> CID_BUDDY_LIST_STATUS_NOTIFY
  16, // 516 -> CID_BUDDY_LIST_USER_INFO_REQUEST
  17, // 517 -> CID_BUDDY_LIST_USER_INFO_RESPONSE
  11, // 518 -> CID_BUDDY_LIST_REMOVE_SESSION_REQ
  12, // 519 -> CID_BUDDY_LIST_REMOVE_SESSION_RES
  0, // 520 -> CID_BUDDY_LIST_ALL_USER_REQUEST
  1, // 521 -> CID_BUDDY_LIST_ALL_USER_RESPONSE
  14, // 522 -> CID_BUDDY_LIST_USERS_STATUS_REQUEST
  15, // 523 -> CID_BUDDY_LIST_USERS_STATUS_RESPONSE
  2, // 524 -> CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST
  3, // 525 -> CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE
  7, // 526 -> CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY
  10, // 527 -> CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY
  4, // 528 -> CID_BUDDY_LIST_DEPARTMENT_REQUEST
  5, // 529 -> CID_BUDDY_LIST_DEPARTMENT_RESPONSE
};

const std::string& BuddyListCmdID_Name(
    BuddyListCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BuddyListCmdID_entries,
          BuddyListCmdID_entries_by_number,
          18, BuddyListCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BuddyListCmdID_entries,
      BuddyListCmdID_entries_by_number,
      18, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BuddyListCmdID_strings[idx].get();
}
bool BuddyListCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BuddyListCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BuddyListCmdID_entries, 18, name, &int_value);
  if (success) {
    *value = static_cast<BuddyListCmdID>(int_value);
  }
  return success;
}
bool MessageCmdID_IsValid(int value) {
  switch (value) {
    case 0:
    case 769:
    case 770:
    case 771:
    case 772:
    case 773:
    case 774:
    case 775:
    case 776:
    case 777:
    case 778:
    case 779:
    case 780:
    case 781:
    case 782:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MessageCmdID_strings[15] = {};

static const char MessageCmdID_names[] =
  "CID_MSG_DATA"
  "CID_MSG_DATA_ACK"
  "CID_MSG_GET_BY_MSG_ID_REQ"
  "CID_MSG_GET_BY_MSG_ID_RES"
  "CID_MSG_GET_LATEST_MSG_ID_REQ"
  "CID_MSG_GET_LATEST_MSG_ID_RSP"
  "CID_MSG_LIST_REQUEST"
  "CID_MSG_LIST_RESPONSE"
  "CID_MSG_NONE"
  "CID_MSG_READ_ACK"
  "CID_MSG_READ_NOTIFY"
  "CID_MSG_TIME_REQUEST"
  "CID_MSG_TIME_RESPONSE"
  "CID_MSG_UNREAD_CNT_REQUEST"
  "CID_MSG_UNREAD_CNT_RESPONSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MessageCmdID_entries[] = {
  { {MessageCmdID_names + 0, 12}, 769 },
  { {MessageCmdID_names + 12, 16}, 770 },
  { {MessageCmdID_names + 28, 25}, 781 },
  { {MessageCmdID_names + 53, 25}, 782 },
  { {MessageCmdID_names + 78, 29}, 779 },
  { {MessageCmdID_names + 107, 29}, 780 },
  { {MessageCmdID_names + 136, 20}, 777 },
  { {MessageCmdID_names + 156, 21}, 778 },
  { {MessageCmdID_names + 177, 12}, 0 },
  { {MessageCmdID_names + 189, 16}, 771 },
  { {MessageCmdID_names + 205, 19}, 772 },
  { {MessageCmdID_names + 224, 20}, 773 },
  { {MessageCmdID_names + 244, 21}, 774 },
  { {MessageCmdID_names + 265, 26}, 775 },
  { {MessageCmdID_names + 291, 27}, 776 },
};

static const int MessageCmdID_entries_by_number[] = {
  8, // 0 -> CID_MSG_NONE
  0, // 769 -> CID_MSG_DATA
  1, // 770 -> CID_MSG_DATA_ACK
  9, // 771 -> CID_MSG_READ_ACK
  10, // 772 -> CID_MSG_READ_NOTIFY
  11, // 773 -> CID_MSG_TIME_REQUEST
  12, // 774 -> CID_MSG_TIME_RESPONSE
  13, // 775 -> CID_MSG_UNREAD_CNT_REQUEST
  14, // 776 -> CID_MSG_UNREAD_CNT_RESPONSE
  6, // 777 -> CID_MSG_LIST_REQUEST
  7, // 778 -> CID_MSG_LIST_RESPONSE
  4, // 779 -> CID_MSG_GET_LATEST_MSG_ID_REQ
  5, // 780 -> CID_MSG_GET_LATEST_MSG_ID_RSP
  2, // 781 -> CID_MSG_GET_BY_MSG_ID_REQ
  3, // 782 -> CID_MSG_GET_BY_MSG_ID_RES
};

const std::string& MessageCmdID_Name(
    MessageCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MessageCmdID_entries,
          MessageCmdID_entries_by_number,
          15, MessageCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MessageCmdID_entries,
      MessageCmdID_entries_by_number,
      15, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MessageCmdID_strings[idx].get();
}
bool MessageCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MessageCmdID_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<MessageCmdID>(int_value);
  }
  return success;
}
bool GroupCmdID_IsValid(int value) {
  switch (value) {
    case 0:
    case 1025:
    case 1026:
    case 1027:
    case 1028:
    case 1029:
    case 1030:
    case 1031:
    case 1032:
    case 1033:
    case 1034:
    case 1035:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GroupCmdID_strings[12] = {};

static const char GroupCmdID_names[] =
  "CID_GROUP_CHANGE_MEMBER_NOTIFY"
  "CID_GROUP_CHANGE_MEMBER_REQUEST"
  "CID_GROUP_CHANGE_MEMBER_RESPONSE"
  "CID_GROUP_CREATE_REQUEST"
  "CID_GROUP_CREATE_RESPONSE"
  "CID_GROUP_INFO_REQUEST"
  "CID_GROUP_INFO_RESPONSE"
  "CID_GROUP_NONE"
  "CID_GROUP_NORMAL_LIST_REQUEST"
  "CID_GROUP_NORMAL_LIST_RESPONSE"
  "CID_GROUP_SHIELD_GROUP_REQUEST"
  "CID_GROUP_SHIELD_GROUP_RESPONSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GroupCmdID_entries[] = {
  { {GroupCmdID_names + 0, 30}, 1035 },
  { {GroupCmdID_names + 30, 31}, 1031 },
  { {GroupCmdID_names + 61, 32}, 1032 },
  { {GroupCmdID_names + 93, 24}, 1029 },
  { {GroupCmdID_names + 117, 25}, 1030 },
  { {GroupCmdID_names + 142, 22}, 1027 },
  { {GroupCmdID_names + 164, 23}, 1028 },
  { {GroupCmdID_names + 187, 14}, 0 },
  { {GroupCmdID_names + 201, 29}, 1025 },
  { {GroupCmdID_names + 230, 30}, 1026 },
  { {GroupCmdID_names + 260, 30}, 1033 },
  { {GroupCmdID_names + 290, 31}, 1034 },
};

static const int GroupCmdID_entries_by_number[] = {
  7, // 0 -> CID_GROUP_NONE
  8, // 1025 -> CID_GROUP_NORMAL_LIST_REQUEST
  9, // 1026 -> CID_GROUP_NORMAL_LIST_RESPONSE
  5, // 1027 -> CID_GROUP_INFO_REQUEST
  6, // 1028 -> CID_GROUP_INFO_RESPONSE
  3, // 1029 -> CID_GROUP_CREATE_REQUEST
  4, // 1030 -> CID_GROUP_CREATE_RESPONSE
  1, // 1031 -> CID_GROUP_CHANGE_MEMBER_REQUEST
  2, // 1032 -> CID_GROUP_CHANGE_MEMBER_RESPONSE
  10, // 1033 -> CID_GROUP_SHIELD_GROUP_REQUEST
  11, // 1034 -> CID_GROUP_SHIELD_GROUP_RESPONSE
  0, // 1035 -> CID_GROUP_CHANGE_MEMBER_NOTIFY
};

const std::string& GroupCmdID_Name(
    GroupCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GroupCmdID_entries,
          GroupCmdID_entries_by_number,
          12, GroupCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GroupCmdID_entries,
      GroupCmdID_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GroupCmdID_strings[idx].get();
}
bool GroupCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GroupCmdID_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<GroupCmdID>(int_value);
  }
  return success;
}
bool FileCmdID_IsValid(int value) {
  switch (value) {
    case 0:
    case 1281:
    case 1282:
    case 1283:
    case 1284:
    case 1285:
    case 1286:
    case 1287:
    case 1288:
    case 1289:
    case 1290:
    case 1291:
    case 1292:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FileCmdID_strings[13] = {};

static const char FileCmdID_names[] =
  "CID_FILE_ADD_OFFLINE_REQ"
  "CID_FILE_DEL_OFFLINE_REQ"
  "CID_FILE_HAS_OFFLINE_REQ"
  "CID_FILE_HAS_OFFLINE_RES"
  "CID_FILE_LOGIN_REQ"
  "CID_FILE_LOGIN_RES"
  "CID_FILE_NONE"
  "CID_FILE_NOTIFY"
  "CID_FILE_PULL_DATA_REQ"
  "CID_FILE_PULL_DATA_RSP"
  "CID_FILE_REQUEST"
  "CID_FILE_RESPONSE"
  "CID_FILE_STATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FileCmdID_entries[] = {
  { {FileCmdID_names + 0, 24}, 1291 },
  { {FileCmdID_names + 24, 24}, 1292 },
  { {FileCmdID_names + 48, 24}, 1289 },
  { {FileCmdID_names + 72, 24}, 1290 },
  { {FileCmdID_names + 96, 18}, 1281 },
  { {FileCmdID_names + 114, 18}, 1282 },
  { {FileCmdID_names + 132, 13}, 0 },
  { {FileCmdID_names + 145, 15}, 1288 },
  { {FileCmdID_names + 160, 22}, 1284 },
  { {FileCmdID_names + 182, 22}, 1285 },
  { {FileCmdID_names + 204, 16}, 1286 },
  { {FileCmdID_names + 220, 17}, 1287 },
  { {FileCmdID_names + 237, 14}, 1283 },
};

static const int FileCmdID_entries_by_number[] = {
  6, // 0 -> CID_FILE_NONE
  4, // 1281 -> CID_FILE_LOGIN_REQ
  5, // 1282 -> CID_FILE_LOGIN_RES
  12, // 1283 -> CID_FILE_STATE
  8, // 1284 -> CID_FILE_PULL_DATA_REQ
  9, // 1285 -> CID_FILE_PULL_DATA_RSP
  10, // 1286 -> CID_FILE_REQUEST
  11, // 1287 -> CID_FILE_RESPONSE
  7, // 1288 -> CID_FILE_NOTIFY
  2, // 1289 -> CID_FILE_HAS_OFFLINE_REQ
  3, // 1290 -> CID_FILE_HAS_OFFLINE_RES
  0, // 1291 -> CID_FILE_ADD_OFFLINE_REQ
  1, // 1292 -> CID_FILE_DEL_OFFLINE_REQ
};

const std::string& FileCmdID_Name(
    FileCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FileCmdID_entries,
          FileCmdID_entries_by_number,
          13, FileCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FileCmdID_entries,
      FileCmdID_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FileCmdID_strings[idx].get();
}
bool FileCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FileCmdID_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<FileCmdID>(int_value);
  }
  return success;
}
bool SwitchServiceCmdID_IsValid(int value) {
  switch (value) {
    case 0:
    case 1537:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SwitchServiceCmdID_strings[2] = {};

static const char SwitchServiceCmdID_names[] =
  "CID_SWITCH_NONE"
  "CID_SWITCH_P2P_CMD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SwitchServiceCmdID_entries[] = {
  { {SwitchServiceCmdID_names + 0, 15}, 0 },
  { {SwitchServiceCmdID_names + 15, 18}, 1537 },
};

static const int SwitchServiceCmdID_entries_by_number[] = {
  0, // 0 -> CID_SWITCH_NONE
  1, // 1537 -> CID_SWITCH_P2P_CMD
};

const std::string& SwitchServiceCmdID_Name(
    SwitchServiceCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SwitchServiceCmdID_entries,
          SwitchServiceCmdID_entries_by_number,
          2, SwitchServiceCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SwitchServiceCmdID_entries,
      SwitchServiceCmdID_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SwitchServiceCmdID_strings[idx].get();
}
bool SwitchServiceCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SwitchServiceCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SwitchServiceCmdID_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SwitchServiceCmdID>(int_value);
  }
  return success;
}
bool OtherCmdID_IsValid(int value) {
  switch (value) {
    case 0:
    case 1793:
    case 1794:
    case 1795:
    case 1796:
    case 1797:
    case 1798:
    case 1799:
    case 1800:
    case 1801:
    case 1802:
    case 1803:
    case 1805:
    case 1806:
    case 1807:
    case 1808:
    case 1809:
    case 1810:
    case 1841:
    case 1842:
    case 1843:
    case 1844:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OtherCmdID_strings[22] = {};

static const char OtherCmdID_names[] =
  "CID_OTHER_FILE_SERVER_IP_REQ"
  "CID_OTHER_FILE_SERVER_IP_RSP"
  "CID_OTHER_FILE_TRANSFER_REQ"
  "CID_OTHER_FILE_TRANSFER_RSP"
  "CID_OTHER_GET_DEVICE_TOKEN_REQ"
  "CID_OTHER_GET_DEVICE_TOKEN_RSP"
  "CID_OTHER_GET_SHIELD_REQ"
  "CID_OTHER_GET_SHIELD_RSP"
  "CID_OTHER_HEARTBEAT"
  "CID_OTHER_LOGIN_STATUS_NOTIFY"
  "CID_OTHER_MSG_SERV_INFO"
  "CID_OTHER_NONE"
  "CID_OTHER_ONLINE_USER_INFO"
  "CID_OTHER_PUSH_TO_USER_REQ"
  "CID_OTHER_PUSH_TO_USER_RSP"
  "CID_OTHER_ROLE_SET"
  "CID_OTHER_SERVER_KICK_USER"
  "CID_OTHER_STOP_RECV_PACKET"
  "CID_OTHER_USER_CNT_UPDATE"
  "CID_OTHER_USER_STATUS_UPDATE"
  "CID_OTHER_VALIDATE_REQ"
  "CID_OTHER_VALIDATE_RSP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OtherCmdID_entries[] = {
  { {OtherCmdID_names + 0, 28}, 1843 },
  { {OtherCmdID_names + 28, 28}, 1844 },
  { {OtherCmdID_names + 56, 27}, 1841 },
  { {OtherCmdID_names + 83, 27}, 1842 },
  { {OtherCmdID_names + 110, 30}, 1797 },
  { {OtherCmdID_names + 140, 30}, 1798 },
  { {OtherCmdID_names + 170, 24}, 1809 },
  { {OtherCmdID_names + 194, 24}, 1810 },
  { {OtherCmdID_names + 218, 19}, 1793 },
  { {OtherCmdID_names + 237, 29}, 1806 },
  { {OtherCmdID_names + 266, 23}, 1801 },
  { {OtherCmdID_names + 289, 14}, 0 },
  { {OtherCmdID_names + 303, 26}, 1800 },
  { {OtherCmdID_names + 329, 26}, 1807 },
  { {OtherCmdID_names + 355, 26}, 1808 },
  { {OtherCmdID_names + 381, 18}, 1799 },
  { {OtherCmdID_names + 399, 26}, 1805 },
  { {OtherCmdID_names + 425, 26}, 1794 },
  { {OtherCmdID_names + 451, 25}, 1803 },
  { {OtherCmdID_names + 476, 28}, 1802 },
  { {OtherCmdID_names + 504, 22}, 1795 },
  { {OtherCmdID_names + 526, 22}, 1796 },
};

static const int OtherCmdID_entries_by_number[] = {
  11, // 0 -> CID_OTHER_NONE
  8, // 1793 -> CID_OTHER_HEARTBEAT
  17, // 1794 -> CID_OTHER_STOP_RECV_PACKET
  20, // 1795 -> CID_OTHER_VALIDATE_REQ
  21, // 1796 -> CID_OTHER_VALIDATE_RSP
  4, // 1797 -> CID_OTHER_GET_DEVICE_TOKEN_REQ
  5, // 1798 -> CID_OTHER_GET_DEVICE_TOKEN_RSP
  15, // 1799 -> CID_OTHER_ROLE_SET
  12, // 1800 -> CID_OTHER_ONLINE_USER_INFO
  10, // 1801 -> CID_OTHER_MSG_SERV_INFO
  19, // 1802 -> CID_OTHER_USER_STATUS_UPDATE
  18, // 1803 -> CID_OTHER_USER_CNT_UPDATE
  16, // 1805 -> CID_OTHER_SERVER_KICK_USER
  9, // 1806 -> CID_OTHER_LOGIN_STATUS_NOTIFY
  13, // 1807 -> CID_OTHER_PUSH_TO_USER_REQ
  14, // 1808 -> CID_OTHER_PUSH_TO_USER_RSP
  6, // 1809 -> CID_OTHER_GET_SHIELD_REQ
  7, // 1810 -> CID_OTHER_GET_SHIELD_RSP
  2, // 1841 -> CID_OTHER_FILE_TRANSFER_REQ
  3, // 1842 -> CID_OTHER_FILE_TRANSFER_RSP
  0, // 1843 -> CID_OTHER_FILE_SERVER_IP_REQ
  1, // 1844 -> CID_OTHER_FILE_SERVER_IP_RSP
};

const std::string& OtherCmdID_Name(
    OtherCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OtherCmdID_entries,
          OtherCmdID_entries_by_number,
          22, OtherCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OtherCmdID_entries,
      OtherCmdID_entries_by_number,
      22, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OtherCmdID_strings[idx].get();
}
bool OtherCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OtherCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OtherCmdID_entries, 22, name, &int_value);
  if (success) {
    *value = static_cast<OtherCmdID>(int_value);
  }
  return success;
}
bool ResultType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ResultType_strings[8] = {};

static const char ResultType_names[] =
  "REFUSE_REASON_DB_VALIDATE_FAILED"
  "REFUSE_REASON_MSG_SERVER_FULL"
  "REFUSE_REASON_NONE"
  "REFUSE_REASON_NO_DB_SERVER"
  "REFUSE_REASON_NO_LOGIN_SERVER"
  "REFUSE_REASON_NO_MSG_SERVER"
  "REFUSE_REASON_NO_ROUTE_SERVER"
  "REFUSE_REASON_VERSION_TOO_OLD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ResultType_entries[] = {
  { {ResultType_names + 0, 32}, 6 },
  { {ResultType_names + 32, 29}, 2 },
  { {ResultType_names + 61, 18}, 0 },
  { {ResultType_names + 79, 26}, 3 },
  { {ResultType_names + 105, 29}, 4 },
  { {ResultType_names + 134, 27}, 1 },
  { {ResultType_names + 161, 29}, 5 },
  { {ResultType_names + 190, 29}, 7 },
};

static const int ResultType_entries_by_number[] = {
  2, // 0 -> REFUSE_REASON_NONE
  5, // 1 -> REFUSE_REASON_NO_MSG_SERVER
  1, // 2 -> REFUSE_REASON_MSG_SERVER_FULL
  3, // 3 -> REFUSE_REASON_NO_DB_SERVER
  4, // 4 -> REFUSE_REASON_NO_LOGIN_SERVER
  6, // 5 -> REFUSE_REASON_NO_ROUTE_SERVER
  0, // 6 -> REFUSE_REASON_DB_VALIDATE_FAILED
  7, // 7 -> REFUSE_REASON_VERSION_TOO_OLD
};

const std::string& ResultType_Name(
    ResultType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ResultType_entries,
          ResultType_entries_by_number,
          8, ResultType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ResultType_entries,
      ResultType_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ResultType_strings[idx].get();
}
bool ResultType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResultType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ResultType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<ResultType>(int_value);
  }
  return success;
}
bool KickReasonType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> KickReasonType_strings[3] = {};

static const char KickReasonType_names[] =
  "KICK_REASON_DUPLICATE_USER"
  "KICK_REASON_MOBILE_KICK"
  "KICK_REASON_NONE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry KickReasonType_entries[] = {
  { {KickReasonType_names + 0, 26}, 1 },
  { {KickReasonType_names + 26, 23}, 2 },
  { {KickReasonType_names + 49, 16}, 0 },
};

static const int KickReasonType_entries_by_number[] = {
  2, // 0 -> KICK_REASON_NONE
  0, // 1 -> KICK_REASON_DUPLICATE_USER
  1, // 2 -> KICK_REASON_MOBILE_KICK
};

const std::string& KickReasonType_Name(
    KickReasonType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          KickReasonType_entries,
          KickReasonType_entries_by_number,
          3, KickReasonType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      KickReasonType_entries,
      KickReasonType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     KickReasonType_strings[idx].get();
}
bool KickReasonType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KickReasonType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      KickReasonType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<KickReasonType>(int_value);
  }
  return success;
}
bool OnlineListType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OnlineListType_strings[2] = {};

static const char OnlineListType_names[] =
  "ONLINE_LIST_TYPE_FRIEND_LIST"
  "ONLINE_LIST_TYPE_NONE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OnlineListType_entries[] = {
  { {OnlineListType_names + 0, 28}, 1 },
  { {OnlineListType_names + 28, 21}, 0 },
};

static const int OnlineListType_entries_by_number[] = {
  1, // 0 -> ONLINE_LIST_TYPE_NONE
  0, // 1 -> ONLINE_LIST_TYPE_FRIEND_LIST
};

const std::string& OnlineListType_Name(
    OnlineListType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OnlineListType_entries,
          OnlineListType_entries_by_number,
          2, OnlineListType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OnlineListType_entries,
      OnlineListType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OnlineListType_strings[idx].get();
}
bool OnlineListType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OnlineListType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OnlineListType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<OnlineListType>(int_value);
  }
  return success;
}
bool UserStatType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserStatType_strings[4] = {};

static const char UserStatType_names[] =
  "USER_STATUS_LEAVE"
  "USER_STATUS_NONE"
  "USER_STATUS_OFFLINE"
  "USER_STATUS_ONLINE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserStatType_entries[] = {
  { {UserStatType_names + 0, 17}, 3 },
  { {UserStatType_names + 17, 16}, 0 },
  { {UserStatType_names + 33, 19}, 2 },
  { {UserStatType_names + 52, 18}, 1 },
};

static const int UserStatType_entries_by_number[] = {
  1, // 0 -> USER_STATUS_NONE
  3, // 1 -> USER_STATUS_ONLINE
  2, // 2 -> USER_STATUS_OFFLINE
  0, // 3 -> USER_STATUS_LEAVE
};

const std::string& UserStatType_Name(
    UserStatType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UserStatType_entries,
          UserStatType_entries_by_number,
          4, UserStatType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UserStatType_entries,
      UserStatType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UserStatType_strings[idx].get();
}
bool UserStatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserStatType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UserStatType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<UserStatType>(int_value);
  }
  return success;
}
bool SessionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SessionType_strings[3] = {};

static const char SessionType_names[] =
  "SESSION_TYPE_GROUP"
  "SESSION_TYPE_NONE"
  "SESSION_TYPE_SINGLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SessionType_entries[] = {
  { {SessionType_names + 0, 18}, 2 },
  { {SessionType_names + 18, 17}, 0 },
  { {SessionType_names + 35, 19}, 1 },
};

static const int SessionType_entries_by_number[] = {
  1, // 0 -> SESSION_TYPE_NONE
  2, // 1 -> SESSION_TYPE_SINGLE
  0, // 2 -> SESSION_TYPE_GROUP
};

const std::string& SessionType_Name(
    SessionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SessionType_entries,
          SessionType_entries_by_number,
          3, SessionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SessionType_entries,
      SessionType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SessionType_strings[idx].get();
}
bool SessionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SessionType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SessionType>(int_value);
  }
  return success;
}
bool MsgType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MsgType_strings[5] = {};

static const char MsgType_names[] =
  "MSG_TYPE_GROUP_AUDIO"
  "MSG_TYPE_GROUP_TEXT"
  "MSG_TYPE_NONE"
  "MSG_TYPE_SINGLE_AUDIO"
  "MSG_TYPE_SINGLE_TEXT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MsgType_entries[] = {
  { {MsgType_names + 0, 20}, 18 },
  { {MsgType_names + 20, 19}, 17 },
  { {MsgType_names + 39, 13}, 0 },
  { {MsgType_names + 52, 21}, 2 },
  { {MsgType_names + 73, 20}, 1 },
};

static const int MsgType_entries_by_number[] = {
  2, // 0 -> MSG_TYPE_NONE
  4, // 1 -> MSG_TYPE_SINGLE_TEXT
  3, // 2 -> MSG_TYPE_SINGLE_AUDIO
  1, // 17 -> MSG_TYPE_GROUP_TEXT
  0, // 18 -> MSG_TYPE_GROUP_AUDIO
};

const std::string& MsgType_Name(
    MsgType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MsgType_entries,
          MsgType_entries_by_number,
          5, MsgType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MsgType_entries,
      MsgType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MsgType_strings[idx].get();
}
bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MsgType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<MsgType>(int_value);
  }
  return success;
}
bool ClientType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientType_strings[5] = {};

static const char ClientType_names[] =
  "CLIENT_TYPE_ANDROID"
  "CLIENT_TYPE_IOS"
  "CLIENT_TYPE_MAC"
  "CLIENT_TYPE_NONE"
  "CLIENT_TYPE_WINDOWS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientType_entries[] = {
  { {ClientType_names + 0, 19}, 18 },
  { {ClientType_names + 19, 15}, 17 },
  { {ClientType_names + 34, 15}, 2 },
  { {ClientType_names + 49, 16}, 0 },
  { {ClientType_names + 65, 19}, 1 },
};

static const int ClientType_entries_by_number[] = {
  3, // 0 -> CLIENT_TYPE_NONE
  4, // 1 -> CLIENT_TYPE_WINDOWS
  2, // 2 -> CLIENT_TYPE_MAC
  1, // 17 -> CLIENT_TYPE_IOS
  0, // 18 -> CLIENT_TYPE_ANDROID
};

const std::string& ClientType_Name(
    ClientType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientType_entries,
          ClientType_entries_by_number,
          5, ClientType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientType_entries,
      ClientType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientType_strings[idx].get();
}
bool ClientType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ClientType>(int_value);
  }
  return success;
}
bool GroupType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GroupType_strings[3] = {};

static const char GroupType_names[] =
  "GROUP_TYPE_NONE"
  "GROUP_TYPE_NORMAL"
  "GROUP_TYPE_TMP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GroupType_entries[] = {
  { {GroupType_names + 0, 15}, 0 },
  { {GroupType_names + 15, 17}, 1 },
  { {GroupType_names + 32, 14}, 2 },
};

static const int GroupType_entries_by_number[] = {
  0, // 0 -> GROUP_TYPE_NONE
  1, // 1 -> GROUP_TYPE_NORMAL
  2, // 2 -> GROUP_TYPE_TMP
};

const std::string& GroupType_Name(
    GroupType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GroupType_entries,
          GroupType_entries_by_number,
          3, GroupType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GroupType_entries,
      GroupType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GroupType_strings[idx].get();
}
bool GroupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GroupType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GroupType>(int_value);
  }
  return success;
}
bool GroupModifyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GroupModifyType_strings[3] = {};

static const char GroupModifyType_names[] =
  "GROUP_MODIFY_NONE"
  "GROUP_MODIFY_TYPE_ADD"
  "GROUP_MODIFY_TYPE_DEL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GroupModifyType_entries[] = {
  { {GroupModifyType_names + 0, 17}, 0 },
  { {GroupModifyType_names + 17, 21}, 1 },
  { {GroupModifyType_names + 38, 21}, 2 },
};

static const int GroupModifyType_entries_by_number[] = {
  0, // 0 -> GROUP_MODIFY_NONE
  1, // 1 -> GROUP_MODIFY_TYPE_ADD
  2, // 2 -> GROUP_MODIFY_TYPE_DEL
};

const std::string& GroupModifyType_Name(
    GroupModifyType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GroupModifyType_entries,
          GroupModifyType_entries_by_number,
          3, GroupModifyType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GroupModifyType_entries,
      GroupModifyType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GroupModifyType_strings[idx].get();
}
bool GroupModifyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupModifyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GroupModifyType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GroupModifyType>(int_value);
  }
  return success;
}
bool FileType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FileType_strings[3] = {};

static const char FileType_names[] =
  "FILE_TYPE_NONE"
  "FILE_TYPE_OFFLINE"
  "FILE_TYPE_ONLINE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FileType_entries[] = {
  { {FileType_names + 0, 14}, 0 },
  { {FileType_names + 14, 17}, 2 },
  { {FileType_names + 31, 16}, 1 },
};

static const int FileType_entries_by_number[] = {
  0, // 0 -> FILE_TYPE_NONE
  2, // 1 -> FILE_TYPE_ONLINE
  1, // 2 -> FILE_TYPE_OFFLINE
};

const std::string& FileType_Name(
    FileType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FileType_entries,
          FileType_entries_by_number,
          3, FileType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FileType_entries,
      FileType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FileType_strings[idx].get();
}
bool FileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FileType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<FileType>(int_value);
  }
  return success;
}
bool ClientFileState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientFileState_strings[4] = {};

static const char ClientFileState_names[] =
  "CLIENT_FILE_CANCEL"
  "CLIENT_FILE_DONE"
  "CLIENT_FILE_PEER_READY"
  "CLIENT_FILE_REFUSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientFileState_entries[] = {
  { {ClientFileState_names + 0, 18}, 1 },
  { {ClientFileState_names + 18, 16}, 3 },
  { {ClientFileState_names + 34, 22}, 0 },
  { {ClientFileState_names + 56, 18}, 2 },
};

static const int ClientFileState_entries_by_number[] = {
  2, // 0 -> CLIENT_FILE_PEER_READY
  0, // 1 -> CLIENT_FILE_CANCEL
  3, // 2 -> CLIENT_FILE_REFUSE
  1, // 3 -> CLIENT_FILE_DONE
};

const std::string& ClientFileState_Name(
    ClientFileState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientFileState_entries,
          ClientFileState_entries_by_number,
          4, ClientFileState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientFileState_entries,
      ClientFileState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientFileState_strings[idx].get();
}
bool ClientFileState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFileState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientFileState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ClientFileState>(int_value);
  }
  return success;
}
bool ClientFileRole_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientFileRole_strings[5] = {};

static const char ClientFileRole_names[] =
  "CLIENT_OFFLINE_DOWNLOAD"
  "CLIENT_OFFLINE_UPLOAD"
  "CLIENT_REALTIME_NONE"
  "CLIENT_REALTIME_RECVER"
  "CLIENT_REALTIME_SENDER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientFileRole_entries[] = {
  { {ClientFileRole_names + 0, 23}, 4 },
  { {ClientFileRole_names + 23, 21}, 3 },
  { {ClientFileRole_names + 44, 20}, 0 },
  { {ClientFileRole_names + 64, 22}, 2 },
  { {ClientFileRole_names + 86, 22}, 1 },
};

static const int ClientFileRole_entries_by_number[] = {
  2, // 0 -> CLIENT_REALTIME_NONE
  4, // 1 -> CLIENT_REALTIME_SENDER
  3, // 2 -> CLIENT_REALTIME_RECVER
  1, // 3 -> CLIENT_OFFLINE_UPLOAD
  0, // 4 -> CLIENT_OFFLINE_DOWNLOAD
};

const std::string& ClientFileRole_Name(
    ClientFileRole value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientFileRole_entries,
          ClientFileRole_entries_by_number,
          5, ClientFileRole_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientFileRole_entries,
      ClientFileRole_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientFileRole_strings[idx].get();
}
bool ClientFileRole_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFileRole* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientFileRole_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ClientFileRole>(int_value);
  }
  return success;
}
bool FileServerError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FileServerError_strings[13] = {};

static const char FileServerError_names[] =
  "FILE_SERVER_ERRNO_CREATE_TASK_ERROR"
  "FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR"
  "FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK"
  "FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN"
  "FILE_SERVER_ERRNO_OK"
  "FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR"
  "FILE_SERVER_ERRNO_PULL_DATA_FINISHED"
  "FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER"
  "FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR"
  "FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR"
  "FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR"
  "FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR"
  "FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FileServerError_entries[] = {
  { {FileServerError_names + 0, 35}, 2 },
  { {FileServerError_names + 35, 38}, 1 },
  { {FileServerError_names + 73, 39}, 4 },
  { {FileServerError_names + 112, 37}, 3 },
  { {FileServerError_names + 149, 20}, 0 },
  { {FileServerError_names + 169, 43}, 10 },
  { {FileServerError_names + 212, 36}, 12 },
  { {FileServerError_names + 248, 41}, 6 },
  { {FileServerError_names + 289, 39}, 7 },
  { {FileServerError_names + 328, 43}, 8 },
  { {FileServerError_names + 371, 50}, 9 },
  { {FileServerError_names + 421, 45}, 11 },
  { {FileServerError_names + 466, 48}, 5 },
};

static const int FileServerError_entries_by_number[] = {
  4, // 0 -> FILE_SERVER_ERRNO_OK
  1, // 1 -> FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR
  0, // 2 -> FILE_SERVER_ERRNO_CREATE_TASK_ERROR
  3, // 3 -> FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN
  2, // 4 -> FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK
  12, // 5 -> FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID
  7, // 6 -> FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER
  8, // 7 -> FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR
  9, // 8 -> FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR
  10, // 9 -> FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR
  5, // 10 -> FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR
  11, // 11 -> FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR
  6, // 12 -> FILE_SERVER_ERRNO_PULL_DATA_FINISHED
};

const std::string& FileServerError_Name(
    FileServerError value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FileServerError_entries,
          FileServerError_entries_by_number,
          13, FileServerError_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FileServerError_entries,
      FileServerError_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FileServerError_strings[idx].get();
}
bool FileServerError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileServerError* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FileServerError_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<FileServerError>(int_value);
  }
  return success;
}
bool SessionStatusType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SessionStatusType_strings[2] = {};

static const char SessionStatusType_names[] =
  "SESSION_STATUS_DELETE"
  "SESSION_STATUS_OK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SessionStatusType_entries[] = {
  { {SessionStatusType_names + 0, 21}, 1 },
  { {SessionStatusType_names + 21, 17}, 0 },
};

static const int SessionStatusType_entries_by_number[] = {
  1, // 0 -> SESSION_STATUS_OK
  0, // 1 -> SESSION_STATUS_DELETE
};

const std::string& SessionStatusType_Name(
    SessionStatusType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SessionStatusType_entries,
          SessionStatusType_entries_by_number,
          2, SessionStatusType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SessionStatusType_entries,
      SessionStatusType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SessionStatusType_strings[idx].get();
}
bool SessionStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionStatusType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SessionStatusType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SessionStatusType>(int_value);
  }
  return success;
}
bool DepartmentStatusType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DepartmentStatusType_strings[2] = {};

static const char DepartmentStatusType_names[] =
  "DEPT_STATUS_DELETE"
  "DEPT_STATUS_OK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DepartmentStatusType_entries[] = {
  { {DepartmentStatusType_names + 0, 18}, 1 },
  { {DepartmentStatusType_names + 18, 14}, 0 },
};

static const int DepartmentStatusType_entries_by_number[] = {
  1, // 0 -> DEPT_STATUS_OK
  0, // 1 -> DEPT_STATUS_DELETE
};

const std::string& DepartmentStatusType_Name(
    DepartmentStatusType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DepartmentStatusType_entries,
          DepartmentStatusType_entries_by_number,
          2, DepartmentStatusType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DepartmentStatusType_entries,
      DepartmentStatusType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DepartmentStatusType_strings[idx].get();
}
bool DepartmentStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DepartmentStatusType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DepartmentStatusType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<DepartmentStatusType>(int_value);
  }
  return success;
}

// ===================================================================

class IpAddr::_Internal {
 public:
};

IpAddr::IpAddr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.IpAddr)
}
IpAddr::IpAddr(const IpAddr& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IpAddr* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ip_){}
    , decltype(_impl_.port_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ip().empty()) {
    _this->_impl_.ip_.Set(from._internal_ip(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.port_ = from._impl_.port_;
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.IpAddr)
}

inline void IpAddr::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ip_){}
    , decltype(_impl_.port_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IpAddr::~IpAddr() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.IpAddr)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IpAddr::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ip_.Destroy();
}

void IpAddr::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IpAddr::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.IpAddr)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ip_.ClearToEmpty();
  _impl_.port_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* IpAddr::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IpAddr::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.IpAddr)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string ip = 1;
  if (!this->_internal_ip().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ip().data(), static_cast<int>(this->_internal_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.IpAddr.ip");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ip(), target);
  }

  // uint32 port = 2;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.IpAddr)
  return target;
}

size_t IpAddr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.IpAddr)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ip = 1;
  if (!this->_internal_ip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());
  }

  // uint32 port = 2;
  if (this->_internal_port() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IpAddr::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IpAddr*>(
      &from));
}

void IpAddr::MergeFrom(const IpAddr& from) {
  IpAddr* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.IpAddr)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ip().empty()) {
    _this->_internal_set_ip(from._internal_ip());
  }
  if (from._internal_port() != 0) {
    _this->_internal_set_port(from._internal_port());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IpAddr::CopyFrom(const IpAddr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.IpAddr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpAddr::IsInitialized() const {
  return true;
}

void IpAddr::InternalSwap(IpAddr* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ip_, lhs_arena,
      &other->_impl_.ip_, rhs_arena
  );
  swap(_impl_.port_, other->_impl_.port_);
}

std::string IpAddr::GetTypeName() const {
  return "IM.BaseDefine.IpAddr";
}


// ===================================================================

class UserInfo::_Internal {
 public:
};

UserInfo::UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.UserInfo)
}
UserInfo::UserInfo(const UserInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UserInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_nick_name_){}
    , decltype(_impl_.avatar_url_){}
    , decltype(_impl_.email_){}
    , decltype(_impl_.user_real_name_){}
    , decltype(_impl_.user_tel_){}
    , decltype(_impl_.user_domain_){}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.user_gender_){}
    , decltype(_impl_.department_id_){}
    , decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.user_nick_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_nick_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_nick_name().empty()) {
    _this->_impl_.user_nick_name_.Set(from._internal_user_nick_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.avatar_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_avatar_url().empty()) {
    _this->_impl_.avatar_url_.Set(from._internal_avatar_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_email().empty()) {
    _this->_impl_.email_.Set(from._internal_email(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_real_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_real_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_real_name().empty()) {
    _this->_impl_.user_real_name_.Set(from._internal_user_real_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_tel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_tel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_tel().empty()) {
    _this->_impl_.user_tel_.Set(from._internal_user_tel(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_domain().empty()) {
    _this->_impl_.user_domain_.Set(from._internal_user_domain(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserInfo)
}

inline void UserInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_nick_name_){}
    , decltype(_impl_.avatar_url_){}
    , decltype(_impl_.email_){}
    , decltype(_impl_.user_real_name_){}
    , decltype(_impl_.user_tel_){}
    , decltype(_impl_.user_domain_){}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.user_gender_){0u}
    , decltype(_impl_.department_id_){0u}
    , decltype(_impl_.status_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.user_nick_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_nick_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.avatar_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_real_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_real_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_tel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_tel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserInfo::~UserInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_nick_name_.Destroy();
  _impl_.avatar_url_.Destroy();
  _impl_.email_.Destroy();
  _impl_.user_real_name_.Destroy();
  _impl_.user_tel_.Destroy();
  _impl_.user_domain_.Destroy();
}

void UserInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.UserInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_nick_name_.ClearToEmpty();
  _impl_.avatar_url_.ClearToEmpty();
  _impl_.email_.ClearToEmpty();
  _impl_.user_real_name_.ClearToEmpty();
  _impl_.user_tel_.ClearToEmpty();
  _impl_.user_domain_.ClearToEmpty();
  ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.status_) -
      reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.status_));
  _internal_metadata_.Clear<std::string>();
}

const char* UserInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 user_gender = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.user_gender_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string user_nick_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user_nick_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string avatar_url = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_avatar_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 department_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.department_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string email = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string user_real_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_user_real_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string user_tel = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_user_tel();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string user_domain = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_user_domain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 status = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.UserInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // uint32 user_gender = 2;
  if (this->_internal_user_gender() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_user_gender(), target);
  }

  // string user_nick_name = 3;
  if (!this->_internal_user_nick_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_nick_name().data(), static_cast<int>(this->_internal_user_nick_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.UserInfo.user_nick_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_user_nick_name(), target);
  }

  // string avatar_url = 4;
  if (!this->_internal_avatar_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_avatar_url().data(), static_cast<int>(this->_internal_avatar_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.UserInfo.avatar_url");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_avatar_url(), target);
  }

  // uint32 department_id = 5;
  if (this->_internal_department_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_department_id(), target);
  }

  // string email = 6;
  if (!this->_internal_email().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_email().data(), static_cast<int>(this->_internal_email().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.UserInfo.email");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_email(), target);
  }

  // string user_real_name = 7;
  if (!this->_internal_user_real_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_real_name().data(), static_cast<int>(this->_internal_user_real_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.UserInfo.user_real_name");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_user_real_name(), target);
  }

  // string user_tel = 8;
  if (!this->_internal_user_tel().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_tel().data(), static_cast<int>(this->_internal_user_tel().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.UserInfo.user_tel");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_user_tel(), target);
  }

  // string user_domain = 9;
  if (!this->_internal_user_domain().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_domain().data(), static_cast<int>(this->_internal_user_domain().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.UserInfo.user_domain");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_user_domain(), target);
  }

  // uint32 status = 10;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.UserInfo)
  return target;
}

size_t UserInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.UserInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_nick_name = 3;
  if (!this->_internal_user_nick_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_nick_name());
  }

  // string avatar_url = 4;
  if (!this->_internal_avatar_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar_url());
  }

  // string email = 6;
  if (!this->_internal_email().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  // string user_real_name = 7;
  if (!this->_internal_user_real_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_real_name());
  }

  // string user_tel = 8;
  if (!this->_internal_user_tel().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_tel());
  }

  // string user_domain = 9;
  if (!this->_internal_user_domain().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_domain());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  // uint32 user_gender = 2;
  if (this->_internal_user_gender() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_gender());
  }

  // uint32 department_id = 5;
  if (this->_internal_department_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_department_id());
  }

  // uint32 status = 10;
  if (this->_internal_status() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserInfo*>(
      &from));
}

void UserInfo::MergeFrom(const UserInfo& from) {
  UserInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.UserInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_nick_name().empty()) {
    _this->_internal_set_user_nick_name(from._internal_user_nick_name());
  }
  if (!from._internal_avatar_url().empty()) {
    _this->_internal_set_avatar_url(from._internal_avatar_url());
  }
  if (!from._internal_email().empty()) {
    _this->_internal_set_email(from._internal_email());
  }
  if (!from._internal_user_real_name().empty()) {
    _this->_internal_set_user_real_name(from._internal_user_real_name());
  }
  if (!from._internal_user_tel().empty()) {
    _this->_internal_set_user_tel(from._internal_user_tel());
  }
  if (!from._internal_user_domain().empty()) {
    _this->_internal_set_user_domain(from._internal_user_domain());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_user_gender() != 0) {
    _this->_internal_set_user_gender(from._internal_user_gender());
  }
  if (from._internal_department_id() != 0) {
    _this->_internal_set_department_id(from._internal_department_id());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserInfo::CopyFrom(const UserInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.UserInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserInfo::IsInitialized() const {
  return true;
}

void UserInfo::InternalSwap(UserInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_nick_name_, lhs_arena,
      &other->_impl_.user_nick_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.avatar_url_, lhs_arena,
      &other->_impl_.avatar_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.email_, lhs_arena,
      &other->_impl_.email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_real_name_, lhs_arena,
      &other->_impl_.user_real_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_tel_, lhs_arena,
      &other->_impl_.user_tel_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_domain_, lhs_arena,
      &other->_impl_.user_domain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserInfo, _impl_.status_)
      + sizeof(UserInfo::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(UserInfo, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string UserInfo::GetTypeName() const {
  return "IM.BaseDefine.UserInfo";
}


// ===================================================================

class ContactSessionInfo::_Internal {
 public:
};

ContactSessionInfo::ContactSessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.ContactSessionInfo)
}
ContactSessionInfo::ContactSessionInfo(const ContactSessionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ContactSessionInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.latest_msg_data_){}
    , decltype(_impl_.session_id_){}
    , decltype(_impl_.session_type_){}
    , decltype(_impl_.session_status_){}
    , decltype(_impl_.updated_time_){}
    , decltype(_impl_.latest_msg_id_){}
    , decltype(_impl_.latest_msg_type_){}
    , decltype(_impl_.latest_msg_from_user_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.latest_msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.latest_msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_latest_msg_data().empty()) {
    _this->_impl_.latest_msg_data_.Set(from._internal_latest_msg_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.session_id_, &from._impl_.session_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.latest_msg_from_user_id_) -
    reinterpret_cast<char*>(&_impl_.session_id_)) + sizeof(_impl_.latest_msg_from_user_id_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.ContactSessionInfo)
}

inline void ContactSessionInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.latest_msg_data_){}
    , decltype(_impl_.session_id_){0u}
    , decltype(_impl_.session_type_){0}
    , decltype(_impl_.session_status_){0}
    , decltype(_impl_.updated_time_){0u}
    , decltype(_impl_.latest_msg_id_){0u}
    , decltype(_impl_.latest_msg_type_){0}
    , decltype(_impl_.latest_msg_from_user_id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.latest_msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.latest_msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContactSessionInfo::~ContactSessionInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.ContactSessionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContactSessionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.latest_msg_data_.Destroy();
}

void ContactSessionInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContactSessionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.ContactSessionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.latest_msg_data_.ClearToEmpty();
  ::memset(&_impl_.session_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.latest_msg_from_user_id_) -
      reinterpret_cast<char*>(&_impl_.session_id_)) + sizeof(_impl_.latest_msg_from_user_id_));
  _internal_metadata_.Clear<std::string>();
}

const char* ContactSessionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.SessionType session_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_session_type(static_cast<::IM::BaseDefine::SessionType>(val));
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.SessionStatusType session_status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_session_status(static_cast<::IM::BaseDefine::SessionStatusType>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 updated_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.updated_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 latest_msg_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.latest_msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes latest_msg_data = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_latest_msg_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.MsgType latest_msg_type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_latest_msg_type(static_cast<::IM::BaseDefine::MsgType>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 latest_msg_from_user_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.latest_msg_from_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContactSessionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.ContactSessionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 session_id = 1;
  if (this->_internal_session_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_session_id(), target);
  }

  // .IM.BaseDefine.SessionType session_type = 2;
  if (this->_internal_session_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_session_type(), target);
  }

  // .IM.BaseDefine.SessionStatusType session_status = 3;
  if (this->_internal_session_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_session_status(), target);
  }

  // uint32 updated_time = 4;
  if (this->_internal_updated_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_updated_time(), target);
  }

  // uint32 latest_msg_id = 5;
  if (this->_internal_latest_msg_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_latest_msg_id(), target);
  }

  // bytes latest_msg_data = 6;
  if (!this->_internal_latest_msg_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_latest_msg_data(), target);
  }

  // .IM.BaseDefine.MsgType latest_msg_type = 7;
  if (this->_internal_latest_msg_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_latest_msg_type(), target);
  }

  // uint32 latest_msg_from_user_id = 8;
  if (this->_internal_latest_msg_from_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_latest_msg_from_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.ContactSessionInfo)
  return target;
}

size_t ContactSessionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.ContactSessionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes latest_msg_data = 6;
  if (!this->_internal_latest_msg_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_latest_msg_data());
  }

  // uint32 session_id = 1;
  if (this->_internal_session_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  // .IM.BaseDefine.SessionType session_type = 2;
  if (this->_internal_session_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  // .IM.BaseDefine.SessionStatusType session_status = 3;
  if (this->_internal_session_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_session_status());
  }

  // uint32 updated_time = 4;
  if (this->_internal_updated_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_updated_time());
  }

  // uint32 latest_msg_id = 5;
  if (this->_internal_latest_msg_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_id());
  }

  // .IM.BaseDefine.MsgType latest_msg_type = 7;
  if (this->_internal_latest_msg_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_latest_msg_type());
  }

  // uint32 latest_msg_from_user_id = 8;
  if (this->_internal_latest_msg_from_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_from_user_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ContactSessionInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ContactSessionInfo*>(
      &from));
}

void ContactSessionInfo::MergeFrom(const ContactSessionInfo& from) {
  ContactSessionInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.ContactSessionInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_latest_msg_data().empty()) {
    _this->_internal_set_latest_msg_data(from._internal_latest_msg_data());
  }
  if (from._internal_session_id() != 0) {
    _this->_internal_set_session_id(from._internal_session_id());
  }
  if (from._internal_session_type() != 0) {
    _this->_internal_set_session_type(from._internal_session_type());
  }
  if (from._internal_session_status() != 0) {
    _this->_internal_set_session_status(from._internal_session_status());
  }
  if (from._internal_updated_time() != 0) {
    _this->_internal_set_updated_time(from._internal_updated_time());
  }
  if (from._internal_latest_msg_id() != 0) {
    _this->_internal_set_latest_msg_id(from._internal_latest_msg_id());
  }
  if (from._internal_latest_msg_type() != 0) {
    _this->_internal_set_latest_msg_type(from._internal_latest_msg_type());
  }
  if (from._internal_latest_msg_from_user_id() != 0) {
    _this->_internal_set_latest_msg_from_user_id(from._internal_latest_msg_from_user_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContactSessionInfo::CopyFrom(const ContactSessionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.ContactSessionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContactSessionInfo::IsInitialized() const {
  return true;
}

void ContactSessionInfo::InternalSwap(ContactSessionInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.latest_msg_data_, lhs_arena,
      &other->_impl_.latest_msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContactSessionInfo, _impl_.latest_msg_from_user_id_)
      + sizeof(ContactSessionInfo::_impl_.latest_msg_from_user_id_)
      - PROTOBUF_FIELD_OFFSET(ContactSessionInfo, _impl_.session_id_)>(
          reinterpret_cast<char*>(&_impl_.session_id_),
          reinterpret_cast<char*>(&other->_impl_.session_id_));
}

std::string ContactSessionInfo::GetTypeName() const {
  return "IM.BaseDefine.ContactSessionInfo";
}


// ===================================================================

class UserStat::_Internal {
 public:
};

UserStat::UserStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.UserStat)
}
UserStat::UserStat(const UserStat& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UserStat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_id_){}
    , decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserStat)
}

inline void UserStat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_id_){0u}
    , decltype(_impl_.status_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UserStat::~UserStat() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserStat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserStat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserStat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserStat::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.UserStat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.status_) -
      reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.status_));
  _internal_metadata_.Clear<std::string>();
}

const char* UserStat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.UserStatType status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::IM::BaseDefine::UserStatType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserStat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.UserStat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // .IM.BaseDefine.UserStatType status = 2;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.UserStat)
  return target;
}

size_t UserStat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.UserStat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  // .IM.BaseDefine.UserStatType status = 2;
  if (this->_internal_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserStat::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserStat*>(
      &from));
}

void UserStat::MergeFrom(const UserStat& from) {
  UserStat* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.UserStat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserStat::CopyFrom(const UserStat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.UserStat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserStat::IsInitialized() const {
  return true;
}

void UserStat::InternalSwap(UserStat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserStat, _impl_.status_)
      + sizeof(UserStat::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(UserStat, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string UserStat::GetTypeName() const {
  return "IM.BaseDefine.UserStat";
}


// ===================================================================

class ServerUserStat::_Internal {
 public:
};

ServerUserStat::ServerUserStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.ServerUserStat)
}
ServerUserStat::ServerUserStat(const ServerUserStat& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ServerUserStat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_id_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.client_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.client_type_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.client_type_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.ServerUserStat)
}

inline void ServerUserStat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_id_){0u}
    , decltype(_impl_.status_){0}
    , decltype(_impl_.client_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ServerUserStat::~ServerUserStat() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.ServerUserStat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServerUserStat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ServerUserStat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServerUserStat::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.ServerUserStat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.client_type_) -
      reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.client_type_));
  _internal_metadata_.Clear<std::string>();
}

const char* ServerUserStat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.UserStatType status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::IM::BaseDefine::UserStatType>(val));
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.ClientType client_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_client_type(static_cast<::IM::BaseDefine::ClientType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServerUserStat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.ServerUserStat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // .IM.BaseDefine.UserStatType status = 2;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  // .IM.BaseDefine.ClientType client_type = 3;
  if (this->_internal_client_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_client_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.ServerUserStat)
  return target;
}

size_t ServerUserStat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.ServerUserStat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  // .IM.BaseDefine.UserStatType status = 2;
  if (this->_internal_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  // .IM.BaseDefine.ClientType client_type = 3;
  if (this->_internal_client_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_client_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServerUserStat::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ServerUserStat*>(
      &from));
}

void ServerUserStat::MergeFrom(const ServerUserStat& from) {
  ServerUserStat* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.ServerUserStat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  if (from._internal_client_type() != 0) {
    _this->_internal_set_client_type(from._internal_client_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServerUserStat::CopyFrom(const ServerUserStat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.ServerUserStat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerUserStat::IsInitialized() const {
  return true;
}

void ServerUserStat::InternalSwap(ServerUserStat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServerUserStat, _impl_.client_type_)
      + sizeof(ServerUserStat::_impl_.client_type_)
      - PROTOBUF_FIELD_OFFSET(ServerUserStat, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string ServerUserStat::GetTypeName() const {
  return "IM.BaseDefine.ServerUserStat";
}


// ===================================================================

class UnreadInfo::_Internal {
 public:
};

UnreadInfo::UnreadInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.UnreadInfo)
}
UnreadInfo::UnreadInfo(const UnreadInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UnreadInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.latest_msg_data_){}
    , decltype(_impl_.session_id_){}
    , decltype(_impl_.session_type_){}
    , decltype(_impl_.unread_cnt_){}
    , decltype(_impl_.latest_msg_id_){}
    , decltype(_impl_.latest_msg_type_){}
    , decltype(_impl_.latest_msg_from_user_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.latest_msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.latest_msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_latest_msg_data().empty()) {
    _this->_impl_.latest_msg_data_.Set(from._internal_latest_msg_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.session_id_, &from._impl_.session_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.latest_msg_from_user_id_) -
    reinterpret_cast<char*>(&_impl_.session_id_)) + sizeof(_impl_.latest_msg_from_user_id_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UnreadInfo)
}

inline void UnreadInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.latest_msg_data_){}
    , decltype(_impl_.session_id_){0u}
    , decltype(_impl_.session_type_){0}
    , decltype(_impl_.unread_cnt_){0u}
    , decltype(_impl_.latest_msg_id_){0u}
    , decltype(_impl_.latest_msg_type_){0}
    , decltype(_impl_.latest_msg_from_user_id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.latest_msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.latest_msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UnreadInfo::~UnreadInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UnreadInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnreadInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.latest_msg_data_.Destroy();
}

void UnreadInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UnreadInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.UnreadInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.latest_msg_data_.ClearToEmpty();
  ::memset(&_impl_.session_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.latest_msg_from_user_id_) -
      reinterpret_cast<char*>(&_impl_.session_id_)) + sizeof(_impl_.latest_msg_from_user_id_));
  _internal_metadata_.Clear<std::string>();
}

const char* UnreadInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.SessionType session_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_session_type(static_cast<::IM::BaseDefine::SessionType>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 unread_cnt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.unread_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 latest_msg_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.latest_msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes latest_msg_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_latest_msg_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.MsgType latest_msg_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_latest_msg_type(static_cast<::IM::BaseDefine::MsgType>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 latest_msg_from_user_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.latest_msg_from_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnreadInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.UnreadInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 session_id = 1;
  if (this->_internal_session_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_session_id(), target);
  }

  // .IM.BaseDefine.SessionType session_type = 2;
  if (this->_internal_session_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_session_type(), target);
  }

  // uint32 unread_cnt = 3;
  if (this->_internal_unread_cnt() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_unread_cnt(), target);
  }

  // uint32 latest_msg_id = 4;
  if (this->_internal_latest_msg_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_latest_msg_id(), target);
  }

  // bytes latest_msg_data = 5;
  if (!this->_internal_latest_msg_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_latest_msg_data(), target);
  }

  // .IM.BaseDefine.MsgType latest_msg_type = 6;
  if (this->_internal_latest_msg_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_latest_msg_type(), target);
  }

  // uint32 latest_msg_from_user_id = 7;
  if (this->_internal_latest_msg_from_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_latest_msg_from_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.UnreadInfo)
  return target;
}

size_t UnreadInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.UnreadInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes latest_msg_data = 5;
  if (!this->_internal_latest_msg_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_latest_msg_data());
  }

  // uint32 session_id = 1;
  if (this->_internal_session_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  // .IM.BaseDefine.SessionType session_type = 2;
  if (this->_internal_session_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  // uint32 unread_cnt = 3;
  if (this->_internal_unread_cnt() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unread_cnt());
  }

  // uint32 latest_msg_id = 4;
  if (this->_internal_latest_msg_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_id());
  }

  // .IM.BaseDefine.MsgType latest_msg_type = 6;
  if (this->_internal_latest_msg_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_latest_msg_type());
  }

  // uint32 latest_msg_from_user_id = 7;
  if (this->_internal_latest_msg_from_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_from_user_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UnreadInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UnreadInfo*>(
      &from));
}

void UnreadInfo::MergeFrom(const UnreadInfo& from) {
  UnreadInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.UnreadInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_latest_msg_data().empty()) {
    _this->_internal_set_latest_msg_data(from._internal_latest_msg_data());
  }
  if (from._internal_session_id() != 0) {
    _this->_internal_set_session_id(from._internal_session_id());
  }
  if (from._internal_session_type() != 0) {
    _this->_internal_set_session_type(from._internal_session_type());
  }
  if (from._internal_unread_cnt() != 0) {
    _this->_internal_set_unread_cnt(from._internal_unread_cnt());
  }
  if (from._internal_latest_msg_id() != 0) {
    _this->_internal_set_latest_msg_id(from._internal_latest_msg_id());
  }
  if (from._internal_latest_msg_type() != 0) {
    _this->_internal_set_latest_msg_type(from._internal_latest_msg_type());
  }
  if (from._internal_latest_msg_from_user_id() != 0) {
    _this->_internal_set_latest_msg_from_user_id(from._internal_latest_msg_from_user_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UnreadInfo::CopyFrom(const UnreadInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.UnreadInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnreadInfo::IsInitialized() const {
  return true;
}

void UnreadInfo::InternalSwap(UnreadInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.latest_msg_data_, lhs_arena,
      &other->_impl_.latest_msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UnreadInfo, _impl_.latest_msg_from_user_id_)
      + sizeof(UnreadInfo::_impl_.latest_msg_from_user_id_)
      - PROTOBUF_FIELD_OFFSET(UnreadInfo, _impl_.session_id_)>(
          reinterpret_cast<char*>(&_impl_.session_id_),
          reinterpret_cast<char*>(&other->_impl_.session_id_));
}

std::string UnreadInfo::GetTypeName() const {
  return "IM.BaseDefine.UnreadInfo";
}


// ===================================================================

class MsgInfo::_Internal {
 public:
};

MsgInfo::MsgInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.MsgInfo)
}
MsgInfo::MsgInfo(const MsgInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MsgInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.msg_data_){}
    , decltype(_impl_.msg_id_){}
    , decltype(_impl_.from_session_id_){}
    , decltype(_impl_.create_time_){}
    , decltype(_impl_.msg_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_msg_data().empty()) {
    _this->_impl_.msg_data_.Set(from._internal_msg_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.msg_id_, &from._impl_.msg_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.msg_type_) -
    reinterpret_cast<char*>(&_impl_.msg_id_)) + sizeof(_impl_.msg_type_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.MsgInfo)
}

inline void MsgInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.msg_data_){}
    , decltype(_impl_.msg_id_){0u}
    , decltype(_impl_.from_session_id_){0u}
    , decltype(_impl_.create_time_){0u}
    , decltype(_impl_.msg_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MsgInfo::~MsgInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.MsgInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MsgInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.msg_data_.Destroy();
}

void MsgInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MsgInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.MsgInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.msg_data_.ClearToEmpty();
  ::memset(&_impl_.msg_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.msg_type_) -
      reinterpret_cast<char*>(&_impl_.msg_id_)) + sizeof(_impl_.msg_type_));
  _internal_metadata_.Clear<std::string>();
}

const char* MsgInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 msg_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 from_session_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.from_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 create_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.create_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.MsgType msg_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_msg_type(static_cast<::IM::BaseDefine::MsgType>(val));
        } else
          goto handle_unusual;
        continue;
      // bytes msg_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_msg_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MsgInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.MsgInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 msg_id = 1;
  if (this->_internal_msg_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_msg_id(), target);
  }

  // uint32 from_session_id = 2;
  if (this->_internal_from_session_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_from_session_id(), target);
  }

  // uint32 create_time = 3;
  if (this->_internal_create_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_create_time(), target);
  }

  // .IM.BaseDefine.MsgType msg_type = 4;
  if (this->_internal_msg_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_msg_type(), target);
  }

  // bytes msg_data = 5;
  if (!this->_internal_msg_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_msg_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.MsgInfo)
  return target;
}

size_t MsgInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.MsgInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes msg_data = 5;
  if (!this->_internal_msg_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_msg_data());
  }

  // uint32 msg_id = 1;
  if (this->_internal_msg_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());
  }

  // uint32 from_session_id = 2;
  if (this->_internal_from_session_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_session_id());
  }

  // uint32 create_time = 3;
  if (this->_internal_create_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_create_time());
  }

  // .IM.BaseDefine.MsgType msg_type = 4;
  if (this->_internal_msg_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_msg_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MsgInfo*>(
      &from));
}

void MsgInfo::MergeFrom(const MsgInfo& from) {
  MsgInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.MsgInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_msg_data().empty()) {
    _this->_internal_set_msg_data(from._internal_msg_data());
  }
  if (from._internal_msg_id() != 0) {
    _this->_internal_set_msg_id(from._internal_msg_id());
  }
  if (from._internal_from_session_id() != 0) {
    _this->_internal_set_from_session_id(from._internal_from_session_id());
  }
  if (from._internal_create_time() != 0) {
    _this->_internal_set_create_time(from._internal_create_time());
  }
  if (from._internal_msg_type() != 0) {
    _this->_internal_set_msg_type(from._internal_msg_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MsgInfo::CopyFrom(const MsgInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.MsgInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgInfo::IsInitialized() const {
  return true;
}

void MsgInfo::InternalSwap(MsgInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.msg_data_, lhs_arena,
      &other->_impl_.msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgInfo, _impl_.msg_type_)
      + sizeof(MsgInfo::_impl_.msg_type_)
      - PROTOBUF_FIELD_OFFSET(MsgInfo, _impl_.msg_id_)>(
          reinterpret_cast<char*>(&_impl_.msg_id_),
          reinterpret_cast<char*>(&other->_impl_.msg_id_));
}

std::string MsgInfo::GetTypeName() const {
  return "IM.BaseDefine.MsgInfo";
}


// ===================================================================

class GroupVersionInfo::_Internal {
 public:
};

GroupVersionInfo::GroupVersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.GroupVersionInfo)
}
GroupVersionInfo::GroupVersionInfo(const GroupVersionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupVersionInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.group_id_){}
    , decltype(_impl_.version_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.version_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.version_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.GroupVersionInfo)
}

inline void GroupVersionInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.group_id_){0u}
    , decltype(_impl_.version_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GroupVersionInfo::~GroupVersionInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.GroupVersionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupVersionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GroupVersionInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupVersionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.GroupVersionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.version_) -
      reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.version_));
  _internal_metadata_.Clear<std::string>();
}

const char* GroupVersionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupVersionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.GroupVersionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 group_id = 1;
  if (this->_internal_group_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  // uint32 version = 2;
  if (this->_internal_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.GroupVersionInfo)
  return target;
}

size_t GroupVersionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.GroupVersionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 group_id = 1;
  if (this->_internal_group_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  // uint32 version = 2;
  if (this->_internal_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupVersionInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupVersionInfo*>(
      &from));
}

void GroupVersionInfo::MergeFrom(const GroupVersionInfo& from) {
  GroupVersionInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.GroupVersionInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_group_id() != 0) {
    _this->_internal_set_group_id(from._internal_group_id());
  }
  if (from._internal_version() != 0) {
    _this->_internal_set_version(from._internal_version());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupVersionInfo::CopyFrom(const GroupVersionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.GroupVersionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupVersionInfo::IsInitialized() const {
  return true;
}

void GroupVersionInfo::InternalSwap(GroupVersionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupVersionInfo, _impl_.version_)
      + sizeof(GroupVersionInfo::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(GroupVersionInfo, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
}

std::string GroupVersionInfo::GetTypeName() const {
  return "IM.BaseDefine.GroupVersionInfo";
}


// ===================================================================

class GroupInfo::_Internal {
 public:
};

GroupInfo::GroupInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.GroupInfo)
}
GroupInfo::GroupInfo(const GroupInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.group_member_list_){from._impl_.group_member_list_}
    , /*decltype(_impl_._group_member_list_cached_byte_size_)*/{0}
    , decltype(_impl_.group_name_){}
    , decltype(_impl_.group_avatar_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.group_creator_id_){}
    , decltype(_impl_.group_type_){}
    , decltype(_impl_.shield_status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.group_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_group_name().empty()) {
    _this->_impl_.group_name_.Set(from._internal_group_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.group_avatar_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_avatar_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_group_avatar().empty()) {
    _this->_impl_.group_avatar_.Set(from._internal_group_avatar(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.shield_status_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.shield_status_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.GroupInfo)
}

inline void GroupInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.group_member_list_){arena}
    , /*decltype(_impl_._group_member_list_cached_byte_size_)*/{0}
    , decltype(_impl_.group_name_){}
    , decltype(_impl_.group_avatar_){}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.group_creator_id_){0u}
    , decltype(_impl_.group_type_){0}
    , decltype(_impl_.shield_status_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.group_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.group_avatar_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_avatar_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupInfo::~GroupInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.GroupInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.group_member_list_.~RepeatedField();
  _impl_.group_name_.Destroy();
  _impl_.group_avatar_.Destroy();
}

void GroupInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.GroupInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.group_member_list_.Clear();
  _impl_.group_name_.ClearToEmpty();
  _impl_.group_avatar_.ClearToEmpty();
  ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.shield_status_) -
      reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.shield_status_));
  _internal_metadata_.Clear<std::string>();
}

const char* GroupInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string group_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_group_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string group_avatar = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_group_avatar();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 group_creator_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.group_creator_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.GroupType group_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_group_type(static_cast<::IM::BaseDefine::GroupType>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 shield_status = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.shield_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 group_member_list = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_group_member_list(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 64) {
          _internal_add_group_member_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.GroupInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 group_id = 1;
  if (this->_internal_group_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  // uint32 version = 2;
  if (this->_internal_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_version(), target);
  }

  // string group_name = 3;
  if (!this->_internal_group_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_group_name().data(), static_cast<int>(this->_internal_group_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.GroupInfo.group_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_group_name(), target);
  }

  // string group_avatar = 4;
  if (!this->_internal_group_avatar().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_group_avatar().data(), static_cast<int>(this->_internal_group_avatar().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.GroupInfo.group_avatar");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_group_avatar(), target);
  }

  // uint32 group_creator_id = 5;
  if (this->_internal_group_creator_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_group_creator_id(), target);
  }

  // .IM.BaseDefine.GroupType group_type = 6;
  if (this->_internal_group_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_group_type(), target);
  }

  // uint32 shield_status = 7;
  if (this->_internal_shield_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_shield_status(), target);
  }

  // repeated uint32 group_member_list = 8;
  {
    int byte_size = _impl_._group_member_list_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          8, _internal_group_member_list(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.GroupInfo)
  return target;
}

size_t GroupInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.GroupInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 group_member_list = 8;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.group_member_list_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._group_member_list_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string group_name = 3;
  if (!this->_internal_group_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_name());
  }

  // string group_avatar = 4;
  if (!this->_internal_group_avatar().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_avatar());
  }

  // uint32 group_id = 1;
  if (this->_internal_group_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  // uint32 version = 2;
  if (this->_internal_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
  }

  // uint32 group_creator_id = 5;
  if (this->_internal_group_creator_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_creator_id());
  }

  // .IM.BaseDefine.GroupType group_type = 6;
  if (this->_internal_group_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_type());
  }

  // uint32 shield_status = 7;
  if (this->_internal_shield_status() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupInfo*>(
      &from));
}

void GroupInfo::MergeFrom(const GroupInfo& from) {
  GroupInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.GroupInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.group_member_list_.MergeFrom(from._impl_.group_member_list_);
  if (!from._internal_group_name().empty()) {
    _this->_internal_set_group_name(from._internal_group_name());
  }
  if (!from._internal_group_avatar().empty()) {
    _this->_internal_set_group_avatar(from._internal_group_avatar());
  }
  if (from._internal_group_id() != 0) {
    _this->_internal_set_group_id(from._internal_group_id());
  }
  if (from._internal_version() != 0) {
    _this->_internal_set_version(from._internal_version());
  }
  if (from._internal_group_creator_id() != 0) {
    _this->_internal_set_group_creator_id(from._internal_group_creator_id());
  }
  if (from._internal_group_type() != 0) {
    _this->_internal_set_group_type(from._internal_group_type());
  }
  if (from._internal_shield_status() != 0) {
    _this->_internal_set_shield_status(from._internal_shield_status());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupInfo::CopyFrom(const GroupInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.GroupInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupInfo::IsInitialized() const {
  return true;
}

void GroupInfo::InternalSwap(GroupInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.group_member_list_.InternalSwap(&other->_impl_.group_member_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.group_name_, lhs_arena,
      &other->_impl_.group_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.group_avatar_, lhs_arena,
      &other->_impl_.group_avatar_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupInfo, _impl_.shield_status_)
      + sizeof(GroupInfo::_impl_.shield_status_)
      - PROTOBUF_FIELD_OFFSET(GroupInfo, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
}

std::string GroupInfo::GetTypeName() const {
  return "IM.BaseDefine.GroupInfo";
}


// ===================================================================

class UserTokenInfo::_Internal {
 public:
};

UserTokenInfo::UserTokenInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.UserTokenInfo)
}
UserTokenInfo::UserTokenInfo(const UserTokenInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UserTokenInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.token_){}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.user_type_){}
    , decltype(_impl_.push_count_){}
    , decltype(_impl_.push_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_token().empty()) {
    _this->_impl_.token_.Set(from._internal_token(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.push_type_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.push_type_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserTokenInfo)
}

inline void UserTokenInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.token_){}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.user_type_){0}
    , decltype(_impl_.push_count_){0u}
    , decltype(_impl_.push_type_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserTokenInfo::~UserTokenInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserTokenInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserTokenInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.token_.Destroy();
}

void UserTokenInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserTokenInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.UserTokenInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.token_.ClearToEmpty();
  ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.push_type_) -
      reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.push_type_));
  _internal_metadata_.Clear<std::string>();
}

const char* UserTokenInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.ClientType user_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_user_type(static_cast<::IM::BaseDefine::ClientType>(val));
        } else
          goto handle_unusual;
        continue;
      // string token = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 push_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.push_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 push_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.push_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserTokenInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.UserTokenInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // .IM.BaseDefine.ClientType user_type = 2;
  if (this->_internal_user_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_user_type(), target);
  }

  // string token = 3;
  if (!this->_internal_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_token().data(), static_cast<int>(this->_internal_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.UserTokenInfo.token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_token(), target);
  }

  // uint32 push_count = 4;
  if (this->_internal_push_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_push_count(), target);
  }

  // uint32 push_type = 5;
  if (this->_internal_push_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_push_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.UserTokenInfo)
  return target;
}

size_t UserTokenInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.UserTokenInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string token = 3;
  if (!this->_internal_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_token());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  // .IM.BaseDefine.ClientType user_type = 2;
  if (this->_internal_user_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_user_type());
  }

  // uint32 push_count = 4;
  if (this->_internal_push_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_push_count());
  }

  // uint32 push_type = 5;
  if (this->_internal_push_type() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_push_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserTokenInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserTokenInfo*>(
      &from));
}

void UserTokenInfo::MergeFrom(const UserTokenInfo& from) {
  UserTokenInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.UserTokenInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_token().empty()) {
    _this->_internal_set_token(from._internal_token());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_user_type() != 0) {
    _this->_internal_set_user_type(from._internal_user_type());
  }
  if (from._internal_push_count() != 0) {
    _this->_internal_set_push_count(from._internal_push_count());
  }
  if (from._internal_push_type() != 0) {
    _this->_internal_set_push_type(from._internal_push_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserTokenInfo::CopyFrom(const UserTokenInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.UserTokenInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserTokenInfo::IsInitialized() const {
  return true;
}

void UserTokenInfo::InternalSwap(UserTokenInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_, lhs_arena,
      &other->_impl_.token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserTokenInfo, _impl_.push_type_)
      + sizeof(UserTokenInfo::_impl_.push_type_)
      - PROTOBUF_FIELD_OFFSET(UserTokenInfo, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string UserTokenInfo::GetTypeName() const {
  return "IM.BaseDefine.UserTokenInfo";
}


// ===================================================================

class PushResult::_Internal {
 public:
};

PushResult::PushResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.PushResult)
}
PushResult::PushResult(const PushResult& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PushResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_token_){}
    , decltype(_impl_.result_code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.user_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_token().empty()) {
    _this->_impl_.user_token_.Set(from._internal_user_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.result_code_ = from._impl_.result_code_;
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.PushResult)
}

inline void PushResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_token_){}
    , decltype(_impl_.result_code_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.user_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PushResult::~PushResult() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.PushResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PushResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_token_.Destroy();
}

void PushResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PushResult::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.PushResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_token_.ClearToEmpty();
  _impl_.result_code_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* PushResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 result_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.result_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PushResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.PushResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user_token = 1;
  if (!this->_internal_user_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_token().data(), static_cast<int>(this->_internal_user_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.PushResult.user_token");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_token(), target);
  }

  // uint32 result_code = 2;
  if (this->_internal_result_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_result_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.PushResult)
  return target;
}

size_t PushResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.PushResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_token = 1;
  if (!this->_internal_user_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_token());
  }

  // uint32 result_code = 2;
  if (this->_internal_result_code() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PushResult::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PushResult*>(
      &from));
}

void PushResult::MergeFrom(const PushResult& from) {
  PushResult* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.PushResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_token().empty()) {
    _this->_internal_set_user_token(from._internal_user_token());
  }
  if (from._internal_result_code() != 0) {
    _this->_internal_set_result_code(from._internal_result_code());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PushResult::CopyFrom(const PushResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.PushResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushResult::IsInitialized() const {
  return true;
}

void PushResult::InternalSwap(PushResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_token_, lhs_arena,
      &other->_impl_.user_token_, rhs_arena
  );
  swap(_impl_.result_code_, other->_impl_.result_code_);
}

std::string PushResult::GetTypeName() const {
  return "IM.BaseDefine.PushResult";
}


// ===================================================================

class ShieldStatus::_Internal {
 public:
};

ShieldStatus::ShieldStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.ShieldStatus)
}
ShieldStatus::ShieldStatus(const ShieldStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ShieldStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_id_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.shield_status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.shield_status_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.shield_status_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.ShieldStatus)
}

inline void ShieldStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_id_){0u}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.shield_status_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ShieldStatus::~ShieldStatus() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.ShieldStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShieldStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ShieldStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShieldStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.ShieldStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.shield_status_) -
      reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.shield_status_));
  _internal_metadata_.Clear<std::string>();
}

const char* ShieldStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 shield_status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.shield_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShieldStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.ShieldStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // uint32 group_id = 2;
  if (this->_internal_group_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group_id(), target);
  }

  // uint32 shield_status = 3;
  if (this->_internal_shield_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_shield_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.ShieldStatus)
  return target;
}

size_t ShieldStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.ShieldStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  // uint32 group_id = 2;
  if (this->_internal_group_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  // uint32 shield_status = 3;
  if (this->_internal_shield_status() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShieldStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShieldStatus*>(
      &from));
}

void ShieldStatus::MergeFrom(const ShieldStatus& from) {
  ShieldStatus* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.ShieldStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_group_id() != 0) {
    _this->_internal_set_group_id(from._internal_group_id());
  }
  if (from._internal_shield_status() != 0) {
    _this->_internal_set_shield_status(from._internal_shield_status());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShieldStatus::CopyFrom(const ShieldStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.ShieldStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShieldStatus::IsInitialized() const {
  return true;
}

void ShieldStatus::InternalSwap(ShieldStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShieldStatus, _impl_.shield_status_)
      + sizeof(ShieldStatus::_impl_.shield_status_)
      - PROTOBUF_FIELD_OFFSET(ShieldStatus, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string ShieldStatus::GetTypeName() const {
  return "IM.BaseDefine.ShieldStatus";
}


// ===================================================================

class OfflineFileInfo::_Internal {
 public:
};

OfflineFileInfo::OfflineFileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.OfflineFileInfo)
}
OfflineFileInfo::OfflineFileInfo(const OfflineFileInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OfflineFileInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.task_id_){}
    , decltype(_impl_.file_name_){}
    , decltype(_impl_.from_user_id_){}
    , decltype(_impl_.file_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.task_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.task_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_task_id().empty()) {
    _this->_impl_.task_id_.Set(from._internal_task_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_name().empty()) {
    _this->_impl_.file_name_.Set(from._internal_file_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.from_user_id_, &from._impl_.from_user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.file_size_) -
    reinterpret_cast<char*>(&_impl_.from_user_id_)) + sizeof(_impl_.file_size_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.OfflineFileInfo)
}

inline void OfflineFileInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.task_id_){}
    , decltype(_impl_.file_name_){}
    , decltype(_impl_.from_user_id_){0u}
    , decltype(_impl_.file_size_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.task_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.task_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OfflineFileInfo::~OfflineFileInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.OfflineFileInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OfflineFileInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.task_id_.Destroy();
  _impl_.file_name_.Destroy();
}

void OfflineFileInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OfflineFileInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.OfflineFileInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.task_id_.ClearToEmpty();
  _impl_.file_name_.ClearToEmpty();
  ::memset(&_impl_.from_user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.file_size_) -
      reinterpret_cast<char*>(&_impl_.from_user_id_)) + sizeof(_impl_.file_size_));
  _internal_metadata_.Clear<std::string>();
}

const char* OfflineFileInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 from_user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.from_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string task_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_task_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string file_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_file_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 file_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.file_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OfflineFileInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.OfflineFileInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 from_user_id = 1;
  if (this->_internal_from_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_from_user_id(), target);
  }

  // string task_id = 2;
  if (!this->_internal_task_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_task_id().data(), static_cast<int>(this->_internal_task_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.OfflineFileInfo.task_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_task_id(), target);
  }

  // string file_name = 3;
  if (!this->_internal_file_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_name().data(), static_cast<int>(this->_internal_file_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.OfflineFileInfo.file_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_file_name(), target);
  }

  // uint32 file_size = 4;
  if (this->_internal_file_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_file_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.OfflineFileInfo)
  return target;
}

size_t OfflineFileInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.OfflineFileInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string task_id = 2;
  if (!this->_internal_task_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_task_id());
  }

  // string file_name = 3;
  if (!this->_internal_file_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_name());
  }

  // uint32 from_user_id = 1;
  if (this->_internal_from_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_user_id());
  }

  // uint32 file_size = 4;
  if (this->_internal_file_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_file_size());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OfflineFileInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OfflineFileInfo*>(
      &from));
}

void OfflineFileInfo::MergeFrom(const OfflineFileInfo& from) {
  OfflineFileInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.OfflineFileInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_task_id().empty()) {
    _this->_internal_set_task_id(from._internal_task_id());
  }
  if (!from._internal_file_name().empty()) {
    _this->_internal_set_file_name(from._internal_file_name());
  }
  if (from._internal_from_user_id() != 0) {
    _this->_internal_set_from_user_id(from._internal_from_user_id());
  }
  if (from._internal_file_size() != 0) {
    _this->_internal_set_file_size(from._internal_file_size());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OfflineFileInfo::CopyFrom(const OfflineFileInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.OfflineFileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfflineFileInfo::IsInitialized() const {
  return true;
}

void OfflineFileInfo::InternalSwap(OfflineFileInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.task_id_, lhs_arena,
      &other->_impl_.task_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.file_name_, lhs_arena,
      &other->_impl_.file_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OfflineFileInfo, _impl_.file_size_)
      + sizeof(OfflineFileInfo::_impl_.file_size_)
      - PROTOBUF_FIELD_OFFSET(OfflineFileInfo, _impl_.from_user_id_)>(
          reinterpret_cast<char*>(&_impl_.from_user_id_),
          reinterpret_cast<char*>(&other->_impl_.from_user_id_));
}

std::string OfflineFileInfo::GetTypeName() const {
  return "IM.BaseDefine.OfflineFileInfo";
}


// ===================================================================

class AuthInfo::_Internal {
 public:
};

AuthInfo::AuthInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.AuthInfo)
}
AuthInfo::AuthInfo(const AuthInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AuthInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.app_key_){}
    , decltype(_impl_.allowd_user_ids_){}
    , decltype(_impl_.allowd_group_ids_){}
    , decltype(_impl_.auth_interfaces_){}
    , decltype(_impl_.auth_ips_){}
    , decltype(_impl_.user_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.app_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_app_key().empty()) {
    _this->_impl_.app_key_.Set(from._internal_app_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.allowd_user_ids_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.allowd_user_ids_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_allowd_user_ids().empty()) {
    _this->_impl_.allowd_user_ids_.Set(from._internal_allowd_user_ids(), 
      _this->GetArenaForAllocation());
  }
  _impl_.allowd_group_ids_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.allowd_group_ids_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_allowd_group_ids().empty()) {
    _this->_impl_.allowd_group_ids_.Set(from._internal_allowd_group_ids(), 
      _this->GetArenaForAllocation());
  }
  _impl_.auth_interfaces_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_interfaces_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_auth_interfaces().empty()) {
    _this->_impl_.auth_interfaces_.Set(from._internal_auth_interfaces(), 
      _this->GetArenaForAllocation());
  }
  _impl_.auth_ips_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_ips_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_auth_ips().empty()) {
    _this->_impl_.auth_ips_.Set(from._internal_auth_ips(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.user_id_ = from._impl_.user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.AuthInfo)
}

inline void AuthInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.app_key_){}
    , decltype(_impl_.allowd_user_ids_){}
    , decltype(_impl_.allowd_group_ids_){}
    , decltype(_impl_.auth_interfaces_){}
    , decltype(_impl_.auth_ips_){}
    , decltype(_impl_.user_id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.app_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.allowd_user_ids_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.allowd_user_ids_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.allowd_group_ids_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.allowd_group_ids_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.auth_interfaces_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_interfaces_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.auth_ips_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_ips_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthInfo::~AuthInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.AuthInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.app_key_.Destroy();
  _impl_.allowd_user_ids_.Destroy();
  _impl_.allowd_group_ids_.Destroy();
  _impl_.auth_interfaces_.Destroy();
  _impl_.auth_ips_.Destroy();
}

void AuthInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.AuthInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.app_key_.ClearToEmpty();
  _impl_.allowd_user_ids_.ClearToEmpty();
  _impl_.allowd_group_ids_.ClearToEmpty();
  _impl_.auth_interfaces_.ClearToEmpty();
  _impl_.auth_ips_.ClearToEmpty();
  _impl_.user_id_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* AuthInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string app_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_app_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string allowd_user_ids = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_allowd_user_ids();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string allowd_group_ids = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_allowd_group_ids();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string auth_interfaces = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_auth_interfaces();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string auth_ips = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_auth_ips();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AuthInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.AuthInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string app_key = 1;
  if (!this->_internal_app_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_app_key().data(), static_cast<int>(this->_internal_app_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.AuthInfo.app_key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_app_key(), target);
  }

  // uint32 user_id = 2;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_user_id(), target);
  }

  // string allowd_user_ids = 3;
  if (!this->_internal_allowd_user_ids().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_allowd_user_ids().data(), static_cast<int>(this->_internal_allowd_user_ids().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.AuthInfo.allowd_user_ids");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_allowd_user_ids(), target);
  }

  // string allowd_group_ids = 4;
  if (!this->_internal_allowd_group_ids().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_allowd_group_ids().data(), static_cast<int>(this->_internal_allowd_group_ids().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.AuthInfo.allowd_group_ids");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_allowd_group_ids(), target);
  }

  // string auth_interfaces = 5;
  if (!this->_internal_auth_interfaces().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_auth_interfaces().data(), static_cast<int>(this->_internal_auth_interfaces().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.AuthInfo.auth_interfaces");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_auth_interfaces(), target);
  }

  // string auth_ips = 6;
  if (!this->_internal_auth_ips().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_auth_ips().data(), static_cast<int>(this->_internal_auth_ips().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.AuthInfo.auth_ips");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_auth_ips(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.AuthInfo)
  return target;
}

size_t AuthInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.AuthInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string app_key = 1;
  if (!this->_internal_app_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_app_key());
  }

  // string allowd_user_ids = 3;
  if (!this->_internal_allowd_user_ids().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_allowd_user_ids());
  }

  // string allowd_group_ids = 4;
  if (!this->_internal_allowd_group_ids().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_allowd_group_ids());
  }

  // string auth_interfaces = 5;
  if (!this->_internal_auth_interfaces().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_auth_interfaces());
  }

  // string auth_ips = 6;
  if (!this->_internal_auth_ips().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_auth_ips());
  }

  // uint32 user_id = 2;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AuthInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AuthInfo*>(
      &from));
}

void AuthInfo::MergeFrom(const AuthInfo& from) {
  AuthInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.AuthInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_app_key().empty()) {
    _this->_internal_set_app_key(from._internal_app_key());
  }
  if (!from._internal_allowd_user_ids().empty()) {
    _this->_internal_set_allowd_user_ids(from._internal_allowd_user_ids());
  }
  if (!from._internal_allowd_group_ids().empty()) {
    _this->_internal_set_allowd_group_ids(from._internal_allowd_group_ids());
  }
  if (!from._internal_auth_interfaces().empty()) {
    _this->_internal_set_auth_interfaces(from._internal_auth_interfaces());
  }
  if (!from._internal_auth_ips().empty()) {
    _this->_internal_set_auth_ips(from._internal_auth_ips());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AuthInfo::CopyFrom(const AuthInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.AuthInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthInfo::IsInitialized() const {
  return true;
}

void AuthInfo::InternalSwap(AuthInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.app_key_, lhs_arena,
      &other->_impl_.app_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.allowd_user_ids_, lhs_arena,
      &other->_impl_.allowd_user_ids_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.allowd_group_ids_, lhs_arena,
      &other->_impl_.allowd_group_ids_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.auth_interfaces_, lhs_arena,
      &other->_impl_.auth_interfaces_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.auth_ips_, lhs_arena,
      &other->_impl_.auth_ips_, rhs_arena
  );
  swap(_impl_.user_id_, other->_impl_.user_id_);
}

std::string AuthInfo::GetTypeName() const {
  return "IM.BaseDefine.AuthInfo";
}


// ===================================================================

class DepartInfo::_Internal {
 public:
};

DepartInfo::DepartInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.BaseDefine.DepartInfo)
}
DepartInfo::DepartInfo(const DepartInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DepartInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dept_name_){}
    , decltype(_impl_.dept_id_){}
    , decltype(_impl_.priority_){}
    , decltype(_impl_.parent_dept_id_){}
    , decltype(_impl_.dept_status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.dept_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dept_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_dept_name().empty()) {
    _this->_impl_.dept_name_.Set(from._internal_dept_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.dept_id_, &from._impl_.dept_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dept_status_) -
    reinterpret_cast<char*>(&_impl_.dept_id_)) + sizeof(_impl_.dept_status_));
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.DepartInfo)
}

inline void DepartInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dept_name_){}
    , decltype(_impl_.dept_id_){0u}
    , decltype(_impl_.priority_){0u}
    , decltype(_impl_.parent_dept_id_){0u}
    , decltype(_impl_.dept_status_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.dept_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dept_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DepartInfo::~DepartInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.DepartInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DepartInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dept_name_.Destroy();
}

void DepartInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DepartInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.BaseDefine.DepartInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dept_name_.ClearToEmpty();
  ::memset(&_impl_.dept_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.dept_status_) -
      reinterpret_cast<char*>(&_impl_.dept_id_)) + sizeof(_impl_.dept_status_));
  _internal_metadata_.Clear<std::string>();
}

const char* DepartInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 dept_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.dept_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 priority = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string dept_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_dept_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 parent_dept_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.parent_dept_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.DepartmentStatusType dept_status = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_dept_status(static_cast<::IM::BaseDefine::DepartmentStatusType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DepartInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.BaseDefine.DepartInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 dept_id = 1;
  if (this->_internal_dept_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_dept_id(), target);
  }

  // uint32 priority = 2;
  if (this->_internal_priority() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_priority(), target);
  }

  // string dept_name = 3;
  if (!this->_internal_dept_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_dept_name().data(), static_cast<int>(this->_internal_dept_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.BaseDefine.DepartInfo.dept_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_dept_name(), target);
  }

  // uint32 parent_dept_id = 4;
  if (this->_internal_parent_dept_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_parent_dept_id(), target);
  }

  // .IM.BaseDefine.DepartmentStatusType dept_status = 5;
  if (this->_internal_dept_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_dept_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.BaseDefine.DepartInfo)
  return target;
}

size_t DepartInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.BaseDefine.DepartInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string dept_name = 3;
  if (!this->_internal_dept_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dept_name());
  }

  // uint32 dept_id = 1;
  if (this->_internal_dept_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dept_id());
  }

  // uint32 priority = 2;
  if (this->_internal_priority() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_priority());
  }

  // uint32 parent_dept_id = 4;
  if (this->_internal_parent_dept_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_parent_dept_id());
  }

  // .IM.BaseDefine.DepartmentStatusType dept_status = 5;
  if (this->_internal_dept_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_dept_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DepartInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DepartInfo*>(
      &from));
}

void DepartInfo::MergeFrom(const DepartInfo& from) {
  DepartInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.BaseDefine.DepartInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_dept_name().empty()) {
    _this->_internal_set_dept_name(from._internal_dept_name());
  }
  if (from._internal_dept_id() != 0) {
    _this->_internal_set_dept_id(from._internal_dept_id());
  }
  if (from._internal_priority() != 0) {
    _this->_internal_set_priority(from._internal_priority());
  }
  if (from._internal_parent_dept_id() != 0) {
    _this->_internal_set_parent_dept_id(from._internal_parent_dept_id());
  }
  if (from._internal_dept_status() != 0) {
    _this->_internal_set_dept_status(from._internal_dept_status());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DepartInfo::CopyFrom(const DepartInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.BaseDefine.DepartInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DepartInfo::IsInitialized() const {
  return true;
}

void DepartInfo::InternalSwap(DepartInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dept_name_, lhs_arena,
      &other->_impl_.dept_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DepartInfo, _impl_.dept_status_)
      + sizeof(DepartInfo::_impl_.dept_status_)
      - PROTOBUF_FIELD_OFFSET(DepartInfo, _impl_.dept_id_)>(
          reinterpret_cast<char*>(&_impl_.dept_id_),
          reinterpret_cast<char*>(&other->_impl_.dept_id_));
}

std::string DepartInfo::GetTypeName() const {
  return "IM.BaseDefine.DepartInfo";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace BaseDefine
}  // namespace IM
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::IpAddr*
Arena::CreateMaybeMessage< ::IM::BaseDefine::IpAddr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::IpAddr >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::UserInfo*
Arena::CreateMaybeMessage< ::IM::BaseDefine::UserInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::UserInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::ContactSessionInfo*
Arena::CreateMaybeMessage< ::IM::BaseDefine::ContactSessionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::ContactSessionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::UserStat*
Arena::CreateMaybeMessage< ::IM::BaseDefine::UserStat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::UserStat >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::ServerUserStat*
Arena::CreateMaybeMessage< ::IM::BaseDefine::ServerUserStat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::ServerUserStat >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::UnreadInfo*
Arena::CreateMaybeMessage< ::IM::BaseDefine::UnreadInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::UnreadInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::MsgInfo*
Arena::CreateMaybeMessage< ::IM::BaseDefine::MsgInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::MsgInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::GroupVersionInfo*
Arena::CreateMaybeMessage< ::IM::BaseDefine::GroupVersionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::GroupVersionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::GroupInfo*
Arena::CreateMaybeMessage< ::IM::BaseDefine::GroupInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::GroupInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::UserTokenInfo*
Arena::CreateMaybeMessage< ::IM::BaseDefine::UserTokenInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::UserTokenInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::PushResult*
Arena::CreateMaybeMessage< ::IM::BaseDefine::PushResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::PushResult >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::ShieldStatus*
Arena::CreateMaybeMessage< ::IM::BaseDefine::ShieldStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::ShieldStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::OfflineFileInfo*
Arena::CreateMaybeMessage< ::IM::BaseDefine::OfflineFileInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::OfflineFileInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::AuthInfo*
Arena::CreateMaybeMessage< ::IM::BaseDefine::AuthInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::AuthInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::BaseDefine::DepartInfo*
Arena::CreateMaybeMessage< ::IM::BaseDefine::DepartInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::BaseDefine::DepartInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
