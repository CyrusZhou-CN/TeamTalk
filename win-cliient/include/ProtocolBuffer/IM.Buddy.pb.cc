// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Buddy.proto

#include "IM.Buddy.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace IM {
namespace Buddy {
PROTOBUF_CONSTEXPR IMRecentContactSessionReq::IMRecentContactSessionReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.latest_update_time_)*/0u} {}
struct IMRecentContactSessionReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMRecentContactSessionReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMRecentContactSessionReqDefaultTypeInternal() {}
  union {
    IMRecentContactSessionReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMRecentContactSessionReqDefaultTypeInternal _IMRecentContactSessionReq_default_instance_;
PROTOBUF_CONSTEXPR IMRecentContactSessionRsp::IMRecentContactSessionRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.contact_session_list_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u} {}
struct IMRecentContactSessionRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMRecentContactSessionRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMRecentContactSessionRspDefaultTypeInternal() {}
  union {
    IMRecentContactSessionRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMRecentContactSessionRspDefaultTypeInternal _IMRecentContactSessionRsp_default_instance_;
PROTOBUF_CONSTEXPR IMUserStatNotify::IMUserStatNotify(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_stat_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IMUserStatNotifyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMUserStatNotifyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMUserStatNotifyDefaultTypeInternal() {}
  union {
    IMUserStatNotify _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMUserStatNotifyDefaultTypeInternal _IMUserStatNotify_default_instance_;
PROTOBUF_CONSTEXPR IMUsersInfoReq::IMUsersInfoReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_id_list_)*/{}
  , /*decltype(_impl_._user_id_list_cached_byte_size_)*/{0}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u} {}
struct IMUsersInfoReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMUsersInfoReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMUsersInfoReqDefaultTypeInternal() {}
  union {
    IMUsersInfoReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMUsersInfoReqDefaultTypeInternal _IMUsersInfoReq_default_instance_;
PROTOBUF_CONSTEXPR IMUsersInfoRsp::IMUsersInfoRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_info_list_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u} {}
struct IMUsersInfoRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMUsersInfoRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMUsersInfoRspDefaultTypeInternal() {}
  union {
    IMUsersInfoRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMUsersInfoRspDefaultTypeInternal _IMUsersInfoRsp_default_instance_;
PROTOBUF_CONSTEXPR IMRemoveSessionReq::IMRemoveSessionReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.session_type_)*/0
  , /*decltype(_impl_.session_id_)*/0u} {}
struct IMRemoveSessionReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMRemoveSessionReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMRemoveSessionReqDefaultTypeInternal() {}
  union {
    IMRemoveSessionReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMRemoveSessionReqDefaultTypeInternal _IMRemoveSessionReq_default_instance_;
PROTOBUF_CONSTEXPR IMRemoveSessionRsp::IMRemoveSessionRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.result_code_)*/0u
  , /*decltype(_impl_.session_type_)*/0
  , /*decltype(_impl_.session_id_)*/0u} {}
struct IMRemoveSessionRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMRemoveSessionRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMRemoveSessionRspDefaultTypeInternal() {}
  union {
    IMRemoveSessionRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMRemoveSessionRspDefaultTypeInternal _IMRemoveSessionRsp_default_instance_;
PROTOBUF_CONSTEXPR IMAllUserReq::IMAllUserReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.latest_update_time_)*/0u} {}
struct IMAllUserReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMAllUserReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMAllUserReqDefaultTypeInternal() {}
  union {
    IMAllUserReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMAllUserReqDefaultTypeInternal _IMAllUserReq_default_instance_;
PROTOBUF_CONSTEXPR IMAllUserRsp::IMAllUserRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_list_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.latest_update_time_)*/0u} {}
struct IMAllUserRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMAllUserRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMAllUserRspDefaultTypeInternal() {}
  union {
    IMAllUserRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMAllUserRspDefaultTypeInternal _IMAllUserRsp_default_instance_;
PROTOBUF_CONSTEXPR IMUsersStatReq::IMUsersStatReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_id_list_)*/{}
  , /*decltype(_impl_._user_id_list_cached_byte_size_)*/{0}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u} {}
struct IMUsersStatReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMUsersStatReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMUsersStatReqDefaultTypeInternal() {}
  union {
    IMUsersStatReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMUsersStatReqDefaultTypeInternal _IMUsersStatReq_default_instance_;
PROTOBUF_CONSTEXPR IMUsersStatRsp::IMUsersStatRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_stat_list_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u} {}
struct IMUsersStatRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMUsersStatRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMUsersStatRspDefaultTypeInternal() {}
  union {
    IMUsersStatRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMUsersStatRspDefaultTypeInternal _IMUsersStatRsp_default_instance_;
PROTOBUF_CONSTEXPR IMChangeAvatarReq::IMChangeAvatarReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.avatar_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u} {}
struct IMChangeAvatarReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMChangeAvatarReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMChangeAvatarReqDefaultTypeInternal() {}
  union {
    IMChangeAvatarReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMChangeAvatarReqDefaultTypeInternal _IMChangeAvatarReq_default_instance_;
PROTOBUF_CONSTEXPR IMChangeAvatarRsp::IMChangeAvatarRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.result_code_)*/0u} {}
struct IMChangeAvatarRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMChangeAvatarRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMChangeAvatarRspDefaultTypeInternal() {}
  union {
    IMChangeAvatarRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMChangeAvatarRspDefaultTypeInternal _IMChangeAvatarRsp_default_instance_;
PROTOBUF_CONSTEXPR IMPCLoginStatusNotify::IMPCLoginStatusNotify(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.login_stat_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IMPCLoginStatusNotifyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMPCLoginStatusNotifyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMPCLoginStatusNotifyDefaultTypeInternal() {}
  union {
    IMPCLoginStatusNotify _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMPCLoginStatusNotifyDefaultTypeInternal _IMPCLoginStatusNotify_default_instance_;
PROTOBUF_CONSTEXPR IMRemoveSessionNotify::IMRemoveSessionNotify(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.session_type_)*/0
  , /*decltype(_impl_.session_id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IMRemoveSessionNotifyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMRemoveSessionNotifyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMRemoveSessionNotifyDefaultTypeInternal() {}
  union {
    IMRemoveSessionNotify _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMRemoveSessionNotifyDefaultTypeInternal _IMRemoveSessionNotify_default_instance_;
PROTOBUF_CONSTEXPR IMDepartmentReq::IMDepartmentReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.latest_update_time_)*/0u} {}
struct IMDepartmentReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMDepartmentReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMDepartmentReqDefaultTypeInternal() {}
  union {
    IMDepartmentReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMDepartmentReqDefaultTypeInternal _IMDepartmentReq_default_instance_;
PROTOBUF_CONSTEXPR IMDepartmentRsp::IMDepartmentRsp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dept_list_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.latest_update_time_)*/0u} {}
struct IMDepartmentRspDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IMDepartmentRspDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IMDepartmentRspDefaultTypeInternal() {}
  union {
    IMDepartmentRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IMDepartmentRspDefaultTypeInternal _IMDepartmentRsp_default_instance_;
}  // namespace Buddy
}  // namespace IM
namespace IM {
namespace Buddy {

// ===================================================================

class IMRecentContactSessionReq::_Internal {
 public:
  using HasBits = decltype(std::declval<IMRecentContactSessionReq>()._impl_._has_bits_);
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IMRecentContactSessionReq::IMRecentContactSessionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMRecentContactSessionReq)
}
IMRecentContactSessionReq::IMRecentContactSessionReq(const IMRecentContactSessionReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMRecentContactSessionReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.latest_update_time_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.latest_update_time_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.latest_update_time_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMRecentContactSessionReq)
}

inline void IMRecentContactSessionReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.latest_update_time_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IMRecentContactSessionReq::~IMRecentContactSessionReq() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMRecentContactSessionReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMRecentContactSessionReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attach_data_.Destroy();
}

void IMRecentContactSessionReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMRecentContactSessionReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMRecentContactSessionReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.latest_update_time_) -
      reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.latest_update_time_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMRecentContactSessionReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 latest_update_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.latest_update_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMRecentContactSessionReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMRecentContactSessionReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // uint32 latest_update_time = 2;
  if (this->_internal_latest_update_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_latest_update_time(), target);
  }

  // optional bytes attach_data = 20;
  if (_internal_has_attach_data()) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMRecentContactSessionReq)
  return target;
}

size_t IMRecentContactSessionReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMRecentContactSessionReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  // uint32 latest_update_time = 2;
  if (this->_internal_latest_update_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_update_time());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMRecentContactSessionReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMRecentContactSessionReq*>(
      &from));
}

void IMRecentContactSessionReq::MergeFrom(const IMRecentContactSessionReq& from) {
  IMRecentContactSessionReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMRecentContactSessionReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_attach_data()) {
    _this->_internal_set_attach_data(from._internal_attach_data());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_latest_update_time() != 0) {
    _this->_internal_set_latest_update_time(from._internal_latest_update_time());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMRecentContactSessionReq::CopyFrom(const IMRecentContactSessionReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMRecentContactSessionReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRecentContactSessionReq::IsInitialized() const {
  return true;
}

void IMRecentContactSessionReq::InternalSwap(IMRecentContactSessionReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMRecentContactSessionReq, _impl_.latest_update_time_)
      + sizeof(IMRecentContactSessionReq::_impl_.latest_update_time_)
      - PROTOBUF_FIELD_OFFSET(IMRecentContactSessionReq, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string IMRecentContactSessionReq::GetTypeName() const {
  return "IM.Buddy.IMRecentContactSessionReq";
}


// ===================================================================

class IMRecentContactSessionRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<IMRecentContactSessionRsp>()._impl_._has_bits_);
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

void IMRecentContactSessionRsp::clear_contact_session_list() {
  _impl_.contact_session_list_.Clear();
}
IMRecentContactSessionRsp::IMRecentContactSessionRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMRecentContactSessionRsp)
}
IMRecentContactSessionRsp::IMRecentContactSessionRsp(const IMRecentContactSessionRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMRecentContactSessionRsp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contact_session_list_){from._impl_.contact_session_list_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.user_id_ = from._impl_.user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMRecentContactSessionRsp)
}

inline void IMRecentContactSessionRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contact_session_list_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IMRecentContactSessionRsp::~IMRecentContactSessionRsp() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMRecentContactSessionRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMRecentContactSessionRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contact_session_list_.~RepeatedPtrField();
  _impl_.attach_data_.Destroy();
}

void IMRecentContactSessionRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMRecentContactSessionRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMRecentContactSessionRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contact_session_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  _impl_.user_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMRecentContactSessionRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_contact_session_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMRecentContactSessionRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMRecentContactSessionRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_contact_session_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_contact_session_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes attach_data = 20;
  if (_internal_has_attach_data()) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMRecentContactSessionRsp)
  return target;
}

size_t IMRecentContactSessionRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMRecentContactSessionRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
  total_size += 1UL * this->_internal_contact_session_list_size();
  for (const auto& msg : this->_impl_.contact_session_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMRecentContactSessionRsp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMRecentContactSessionRsp*>(
      &from));
}

void IMRecentContactSessionRsp::MergeFrom(const IMRecentContactSessionRsp& from) {
  IMRecentContactSessionRsp* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMRecentContactSessionRsp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.contact_session_list_.MergeFrom(from._impl_.contact_session_list_);
  if (from._internal_has_attach_data()) {
    _this->_internal_set_attach_data(from._internal_attach_data());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMRecentContactSessionRsp::CopyFrom(const IMRecentContactSessionRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMRecentContactSessionRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRecentContactSessionRsp::IsInitialized() const {
  return true;
}

void IMRecentContactSessionRsp::InternalSwap(IMRecentContactSessionRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.contact_session_list_.InternalSwap(&other->_impl_.contact_session_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  swap(_impl_.user_id_, other->_impl_.user_id_);
}

std::string IMRecentContactSessionRsp::GetTypeName() const {
  return "IM.Buddy.IMRecentContactSessionRsp";
}


// ===================================================================

class IMUserStatNotify::_Internal {
 public:
  static const ::IM::BaseDefine::UserStat& user_stat(const IMUserStatNotify* msg);
};

const ::IM::BaseDefine::UserStat&
IMUserStatNotify::_Internal::user_stat(const IMUserStatNotify* msg) {
  return *msg->_impl_.user_stat_;
}
void IMUserStatNotify::clear_user_stat() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_stat_ != nullptr) {
    delete _impl_.user_stat_;
  }
  _impl_.user_stat_ = nullptr;
}
IMUserStatNotify::IMUserStatNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMUserStatNotify)
}
IMUserStatNotify::IMUserStatNotify(const IMUserStatNotify& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMUserStatNotify* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_stat_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_user_stat()) {
    _this->_impl_.user_stat_ = new ::IM::BaseDefine::UserStat(*from._impl_.user_stat_);
  }
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMUserStatNotify)
}

inline void IMUserStatNotify::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_stat_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

IMUserStatNotify::~IMUserStatNotify() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMUserStatNotify)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMUserStatNotify::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.user_stat_;
}

void IMUserStatNotify::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMUserStatNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMUserStatNotify)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.user_stat_ != nullptr) {
    delete _impl_.user_stat_;
  }
  _impl_.user_stat_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* IMUserStatNotify::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .IM.BaseDefine.UserStat user_stat = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_stat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMUserStatNotify::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMUserStatNotify)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .IM.BaseDefine.UserStat user_stat = 1;
  if (this->_internal_has_user_stat()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::user_stat(this),
        _Internal::user_stat(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMUserStatNotify)
  return target;
}

size_t IMUserStatNotify::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMUserStatNotify)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .IM.BaseDefine.UserStat user_stat = 1;
  if (this->_internal_has_user_stat()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.user_stat_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMUserStatNotify::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMUserStatNotify*>(
      &from));
}

void IMUserStatNotify::MergeFrom(const IMUserStatNotify& from) {
  IMUserStatNotify* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMUserStatNotify)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user_stat()) {
    _this->_internal_mutable_user_stat()->::IM::BaseDefine::UserStat::MergeFrom(
        from._internal_user_stat());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMUserStatNotify::CopyFrom(const IMUserStatNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMUserStatNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUserStatNotify::IsInitialized() const {
  return true;
}

void IMUserStatNotify::InternalSwap(IMUserStatNotify* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.user_stat_, other->_impl_.user_stat_);
}

std::string IMUserStatNotify::GetTypeName() const {
  return "IM.Buddy.IMUserStatNotify";
}


// ===================================================================

class IMUsersInfoReq::_Internal {
 public:
  using HasBits = decltype(std::declval<IMUsersInfoReq>()._impl_._has_bits_);
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IMUsersInfoReq::IMUsersInfoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMUsersInfoReq)
}
IMUsersInfoReq::IMUsersInfoReq(const IMUsersInfoReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMUsersInfoReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_id_list_){from._impl_.user_id_list_}
    , /*decltype(_impl_._user_id_list_cached_byte_size_)*/{0}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.user_id_ = from._impl_.user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMUsersInfoReq)
}

inline void IMUsersInfoReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_id_list_){arena}
    , /*decltype(_impl_._user_id_list_cached_byte_size_)*/{0}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IMUsersInfoReq::~IMUsersInfoReq() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMUsersInfoReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMUsersInfoReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_id_list_.~RepeatedField();
  _impl_.attach_data_.Destroy();
}

void IMUsersInfoReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMUsersInfoReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMUsersInfoReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_id_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  _impl_.user_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMUsersInfoReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 user_id_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_user_id_list(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_user_id_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMUsersInfoReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMUsersInfoReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // repeated uint32 user_id_list = 2;
  {
    int byte_size = _impl_._user_id_list_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_user_id_list(), byte_size, target);
    }
  }

  // optional bytes attach_data = 20;
  if (_internal_has_attach_data()) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMUsersInfoReq)
  return target;
}

size_t IMUsersInfoReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMUsersInfoReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 user_id_list = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.user_id_list_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._user_id_list_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMUsersInfoReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMUsersInfoReq*>(
      &from));
}

void IMUsersInfoReq::MergeFrom(const IMUsersInfoReq& from) {
  IMUsersInfoReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMUsersInfoReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.user_id_list_.MergeFrom(from._impl_.user_id_list_);
  if (from._internal_has_attach_data()) {
    _this->_internal_set_attach_data(from._internal_attach_data());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMUsersInfoReq::CopyFrom(const IMUsersInfoReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMUsersInfoReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUsersInfoReq::IsInitialized() const {
  return true;
}

void IMUsersInfoReq::InternalSwap(IMUsersInfoReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.user_id_list_.InternalSwap(&other->_impl_.user_id_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  swap(_impl_.user_id_, other->_impl_.user_id_);
}

std::string IMUsersInfoReq::GetTypeName() const {
  return "IM.Buddy.IMUsersInfoReq";
}


// ===================================================================

class IMUsersInfoRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<IMUsersInfoRsp>()._impl_._has_bits_);
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

void IMUsersInfoRsp::clear_user_info_list() {
  _impl_.user_info_list_.Clear();
}
IMUsersInfoRsp::IMUsersInfoRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMUsersInfoRsp)
}
IMUsersInfoRsp::IMUsersInfoRsp(const IMUsersInfoRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMUsersInfoRsp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_info_list_){from._impl_.user_info_list_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.user_id_ = from._impl_.user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMUsersInfoRsp)
}

inline void IMUsersInfoRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_info_list_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IMUsersInfoRsp::~IMUsersInfoRsp() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMUsersInfoRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMUsersInfoRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_info_list_.~RepeatedPtrField();
  _impl_.attach_data_.Destroy();
}

void IMUsersInfoRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMUsersInfoRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMUsersInfoRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_info_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  _impl_.user_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMUsersInfoRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .IM.BaseDefine.UserInfo user_info_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_user_info_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMUsersInfoRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMUsersInfoRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // repeated .IM.BaseDefine.UserInfo user_info_list = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_user_info_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_user_info_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes attach_data = 20;
  if (_internal_has_attach_data()) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMUsersInfoRsp)
  return target;
}

size_t IMUsersInfoRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMUsersInfoRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IM.BaseDefine.UserInfo user_info_list = 2;
  total_size += 1UL * this->_internal_user_info_list_size();
  for (const auto& msg : this->_impl_.user_info_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMUsersInfoRsp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMUsersInfoRsp*>(
      &from));
}

void IMUsersInfoRsp::MergeFrom(const IMUsersInfoRsp& from) {
  IMUsersInfoRsp* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMUsersInfoRsp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.user_info_list_.MergeFrom(from._impl_.user_info_list_);
  if (from._internal_has_attach_data()) {
    _this->_internal_set_attach_data(from._internal_attach_data());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMUsersInfoRsp::CopyFrom(const IMUsersInfoRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMUsersInfoRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUsersInfoRsp::IsInitialized() const {
  return true;
}

void IMUsersInfoRsp::InternalSwap(IMUsersInfoRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.user_info_list_.InternalSwap(&other->_impl_.user_info_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  swap(_impl_.user_id_, other->_impl_.user_id_);
}

std::string IMUsersInfoRsp::GetTypeName() const {
  return "IM.Buddy.IMUsersInfoRsp";
}


// ===================================================================

class IMRemoveSessionReq::_Internal {
 public:
  using HasBits = decltype(std::declval<IMRemoveSessionReq>()._impl_._has_bits_);
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IMRemoveSessionReq::IMRemoveSessionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMRemoveSessionReq)
}
IMRemoveSessionReq::IMRemoveSessionReq(const IMRemoveSessionReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMRemoveSessionReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.session_type_){}
    , decltype(_impl_.session_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.session_id_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.session_id_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMRemoveSessionReq)
}

inline void IMRemoveSessionReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.session_type_){0}
    , decltype(_impl_.session_id_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IMRemoveSessionReq::~IMRemoveSessionReq() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMRemoveSessionReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMRemoveSessionReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attach_data_.Destroy();
}

void IMRemoveSessionReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMRemoveSessionReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMRemoveSessionReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.session_id_) -
      reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.session_id_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMRemoveSessionReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.SessionType session_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_session_type(static_cast<::IM::BaseDefine::SessionType>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 session_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMRemoveSessionReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMRemoveSessionReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // .IM.BaseDefine.SessionType session_type = 2;
  if (this->_internal_session_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_session_type(), target);
  }

  // uint32 session_id = 3;
  if (this->_internal_session_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_session_id(), target);
  }

  // optional bytes attach_data = 20;
  if (_internal_has_attach_data()) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMRemoveSessionReq)
  return target;
}

size_t IMRemoveSessionReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMRemoveSessionReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  // .IM.BaseDefine.SessionType session_type = 2;
  if (this->_internal_session_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  // uint32 session_id = 3;
  if (this->_internal_session_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMRemoveSessionReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMRemoveSessionReq*>(
      &from));
}

void IMRemoveSessionReq::MergeFrom(const IMRemoveSessionReq& from) {
  IMRemoveSessionReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMRemoveSessionReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_attach_data()) {
    _this->_internal_set_attach_data(from._internal_attach_data());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_session_type() != 0) {
    _this->_internal_set_session_type(from._internal_session_type());
  }
  if (from._internal_session_id() != 0) {
    _this->_internal_set_session_id(from._internal_session_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMRemoveSessionReq::CopyFrom(const IMRemoveSessionReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMRemoveSessionReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRemoveSessionReq::IsInitialized() const {
  return true;
}

void IMRemoveSessionReq::InternalSwap(IMRemoveSessionReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMRemoveSessionReq, _impl_.session_id_)
      + sizeof(IMRemoveSessionReq::_impl_.session_id_)
      - PROTOBUF_FIELD_OFFSET(IMRemoveSessionReq, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string IMRemoveSessionReq::GetTypeName() const {
  return "IM.Buddy.IMRemoveSessionReq";
}


// ===================================================================

class IMRemoveSessionRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<IMRemoveSessionRsp>()._impl_._has_bits_);
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IMRemoveSessionRsp::IMRemoveSessionRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMRemoveSessionRsp)
}
IMRemoveSessionRsp::IMRemoveSessionRsp(const IMRemoveSessionRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMRemoveSessionRsp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.result_code_){}
    , decltype(_impl_.session_type_){}
    , decltype(_impl_.session_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.session_id_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.session_id_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMRemoveSessionRsp)
}

inline void IMRemoveSessionRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.result_code_){0u}
    , decltype(_impl_.session_type_){0}
    , decltype(_impl_.session_id_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IMRemoveSessionRsp::~IMRemoveSessionRsp() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMRemoveSessionRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMRemoveSessionRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attach_data_.Destroy();
}

void IMRemoveSessionRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMRemoveSessionRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMRemoveSessionRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.session_id_) -
      reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.session_id_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMRemoveSessionRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 result_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.result_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.SessionType session_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_session_type(static_cast<::IM::BaseDefine::SessionType>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 session_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMRemoveSessionRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMRemoveSessionRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // uint32 result_code = 2;
  if (this->_internal_result_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_result_code(), target);
  }

  // .IM.BaseDefine.SessionType session_type = 3;
  if (this->_internal_session_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_session_type(), target);
  }

  // uint32 session_id = 4;
  if (this->_internal_session_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_session_id(), target);
  }

  // optional bytes attach_data = 20;
  if (_internal_has_attach_data()) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMRemoveSessionRsp)
  return target;
}

size_t IMRemoveSessionRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMRemoveSessionRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  // uint32 result_code = 2;
  if (this->_internal_result_code() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result_code());
  }

  // .IM.BaseDefine.SessionType session_type = 3;
  if (this->_internal_session_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  // uint32 session_id = 4;
  if (this->_internal_session_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMRemoveSessionRsp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMRemoveSessionRsp*>(
      &from));
}

void IMRemoveSessionRsp::MergeFrom(const IMRemoveSessionRsp& from) {
  IMRemoveSessionRsp* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMRemoveSessionRsp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_attach_data()) {
    _this->_internal_set_attach_data(from._internal_attach_data());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_result_code() != 0) {
    _this->_internal_set_result_code(from._internal_result_code());
  }
  if (from._internal_session_type() != 0) {
    _this->_internal_set_session_type(from._internal_session_type());
  }
  if (from._internal_session_id() != 0) {
    _this->_internal_set_session_id(from._internal_session_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMRemoveSessionRsp::CopyFrom(const IMRemoveSessionRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMRemoveSessionRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRemoveSessionRsp::IsInitialized() const {
  return true;
}

void IMRemoveSessionRsp::InternalSwap(IMRemoveSessionRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMRemoveSessionRsp, _impl_.session_id_)
      + sizeof(IMRemoveSessionRsp::_impl_.session_id_)
      - PROTOBUF_FIELD_OFFSET(IMRemoveSessionRsp, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string IMRemoveSessionRsp::GetTypeName() const {
  return "IM.Buddy.IMRemoveSessionRsp";
}


// ===================================================================

class IMAllUserReq::_Internal {
 public:
  using HasBits = decltype(std::declval<IMAllUserReq>()._impl_._has_bits_);
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IMAllUserReq::IMAllUserReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMAllUserReq)
}
IMAllUserReq::IMAllUserReq(const IMAllUserReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMAllUserReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.latest_update_time_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.latest_update_time_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.latest_update_time_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMAllUserReq)
}

inline void IMAllUserReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.latest_update_time_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IMAllUserReq::~IMAllUserReq() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMAllUserReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMAllUserReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attach_data_.Destroy();
}

void IMAllUserReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMAllUserReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMAllUserReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.latest_update_time_) -
      reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.latest_update_time_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMAllUserReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 latest_update_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.latest_update_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMAllUserReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMAllUserReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // uint32 latest_update_time = 2;
  if (this->_internal_latest_update_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_latest_update_time(), target);
  }

  // optional bytes attach_data = 20;
  if (_internal_has_attach_data()) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMAllUserReq)
  return target;
}

size_t IMAllUserReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMAllUserReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  // uint32 latest_update_time = 2;
  if (this->_internal_latest_update_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_update_time());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMAllUserReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMAllUserReq*>(
      &from));
}

void IMAllUserReq::MergeFrom(const IMAllUserReq& from) {
  IMAllUserReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMAllUserReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_attach_data()) {
    _this->_internal_set_attach_data(from._internal_attach_data());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_latest_update_time() != 0) {
    _this->_internal_set_latest_update_time(from._internal_latest_update_time());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMAllUserReq::CopyFrom(const IMAllUserReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMAllUserReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMAllUserReq::IsInitialized() const {
  return true;
}

void IMAllUserReq::InternalSwap(IMAllUserReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMAllUserReq, _impl_.latest_update_time_)
      + sizeof(IMAllUserReq::_impl_.latest_update_time_)
      - PROTOBUF_FIELD_OFFSET(IMAllUserReq, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string IMAllUserReq::GetTypeName() const {
  return "IM.Buddy.IMAllUserReq";
}


// ===================================================================

class IMAllUserRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<IMAllUserRsp>()._impl_._has_bits_);
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

void IMAllUserRsp::clear_user_list() {
  _impl_.user_list_.Clear();
}
IMAllUserRsp::IMAllUserRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMAllUserRsp)
}
IMAllUserRsp::IMAllUserRsp(const IMAllUserRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMAllUserRsp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_list_){from._impl_.user_list_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.latest_update_time_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.latest_update_time_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.latest_update_time_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMAllUserRsp)
}

inline void IMAllUserRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_list_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.latest_update_time_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IMAllUserRsp::~IMAllUserRsp() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMAllUserRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMAllUserRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_list_.~RepeatedPtrField();
  _impl_.attach_data_.Destroy();
}

void IMAllUserRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMAllUserRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMAllUserRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.latest_update_time_) -
      reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.latest_update_time_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMAllUserRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 latest_update_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.latest_update_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .IM.BaseDefine.UserInfo user_list = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_user_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMAllUserRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMAllUserRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // uint32 latest_update_time = 2;
  if (this->_internal_latest_update_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_latest_update_time(), target);
  }

  // repeated .IM.BaseDefine.UserInfo user_list = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_user_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_user_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes attach_data = 20;
  if (_internal_has_attach_data()) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMAllUserRsp)
  return target;
}

size_t IMAllUserRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMAllUserRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IM.BaseDefine.UserInfo user_list = 3;
  total_size += 1UL * this->_internal_user_list_size();
  for (const auto& msg : this->_impl_.user_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  // uint32 latest_update_time = 2;
  if (this->_internal_latest_update_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_update_time());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMAllUserRsp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMAllUserRsp*>(
      &from));
}

void IMAllUserRsp::MergeFrom(const IMAllUserRsp& from) {
  IMAllUserRsp* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMAllUserRsp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.user_list_.MergeFrom(from._impl_.user_list_);
  if (from._internal_has_attach_data()) {
    _this->_internal_set_attach_data(from._internal_attach_data());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_latest_update_time() != 0) {
    _this->_internal_set_latest_update_time(from._internal_latest_update_time());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMAllUserRsp::CopyFrom(const IMAllUserRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMAllUserRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMAllUserRsp::IsInitialized() const {
  return true;
}

void IMAllUserRsp::InternalSwap(IMAllUserRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.user_list_.InternalSwap(&other->_impl_.user_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMAllUserRsp, _impl_.latest_update_time_)
      + sizeof(IMAllUserRsp::_impl_.latest_update_time_)
      - PROTOBUF_FIELD_OFFSET(IMAllUserRsp, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string IMAllUserRsp::GetTypeName() const {
  return "IM.Buddy.IMAllUserRsp";
}


// ===================================================================

class IMUsersStatReq::_Internal {
 public:
  using HasBits = decltype(std::declval<IMUsersStatReq>()._impl_._has_bits_);
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IMUsersStatReq::IMUsersStatReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMUsersStatReq)
}
IMUsersStatReq::IMUsersStatReq(const IMUsersStatReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMUsersStatReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_id_list_){from._impl_.user_id_list_}
    , /*decltype(_impl_._user_id_list_cached_byte_size_)*/{0}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.user_id_ = from._impl_.user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMUsersStatReq)
}

inline void IMUsersStatReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_id_list_){arena}
    , /*decltype(_impl_._user_id_list_cached_byte_size_)*/{0}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IMUsersStatReq::~IMUsersStatReq() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMUsersStatReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMUsersStatReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_id_list_.~RepeatedField();
  _impl_.attach_data_.Destroy();
}

void IMUsersStatReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMUsersStatReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMUsersStatReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_id_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  _impl_.user_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMUsersStatReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 user_id_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_user_id_list(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_user_id_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMUsersStatReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMUsersStatReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // repeated uint32 user_id_list = 2;
  {
    int byte_size = _impl_._user_id_list_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_user_id_list(), byte_size, target);
    }
  }

  // optional bytes attach_data = 20;
  if (_internal_has_attach_data()) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMUsersStatReq)
  return target;
}

size_t IMUsersStatReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMUsersStatReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 user_id_list = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.user_id_list_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._user_id_list_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMUsersStatReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMUsersStatReq*>(
      &from));
}

void IMUsersStatReq::MergeFrom(const IMUsersStatReq& from) {
  IMUsersStatReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMUsersStatReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.user_id_list_.MergeFrom(from._impl_.user_id_list_);
  if (from._internal_has_attach_data()) {
    _this->_internal_set_attach_data(from._internal_attach_data());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMUsersStatReq::CopyFrom(const IMUsersStatReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMUsersStatReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUsersStatReq::IsInitialized() const {
  return true;
}

void IMUsersStatReq::InternalSwap(IMUsersStatReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.user_id_list_.InternalSwap(&other->_impl_.user_id_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  swap(_impl_.user_id_, other->_impl_.user_id_);
}

std::string IMUsersStatReq::GetTypeName() const {
  return "IM.Buddy.IMUsersStatReq";
}


// ===================================================================

class IMUsersStatRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<IMUsersStatRsp>()._impl_._has_bits_);
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

void IMUsersStatRsp::clear_user_stat_list() {
  _impl_.user_stat_list_.Clear();
}
IMUsersStatRsp::IMUsersStatRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMUsersStatRsp)
}
IMUsersStatRsp::IMUsersStatRsp(const IMUsersStatRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMUsersStatRsp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_stat_list_){from._impl_.user_stat_list_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.user_id_ = from._impl_.user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMUsersStatRsp)
}

inline void IMUsersStatRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_stat_list_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IMUsersStatRsp::~IMUsersStatRsp() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMUsersStatRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMUsersStatRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_stat_list_.~RepeatedPtrField();
  _impl_.attach_data_.Destroy();
}

void IMUsersStatRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMUsersStatRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMUsersStatRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_stat_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  _impl_.user_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMUsersStatRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .IM.BaseDefine.UserStat user_stat_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_user_stat_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMUsersStatRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMUsersStatRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // repeated .IM.BaseDefine.UserStat user_stat_list = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_user_stat_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_user_stat_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes attach_data = 20;
  if (_internal_has_attach_data()) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMUsersStatRsp)
  return target;
}

size_t IMUsersStatRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMUsersStatRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IM.BaseDefine.UserStat user_stat_list = 2;
  total_size += 1UL * this->_internal_user_stat_list_size();
  for (const auto& msg : this->_impl_.user_stat_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMUsersStatRsp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMUsersStatRsp*>(
      &from));
}

void IMUsersStatRsp::MergeFrom(const IMUsersStatRsp& from) {
  IMUsersStatRsp* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMUsersStatRsp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.user_stat_list_.MergeFrom(from._impl_.user_stat_list_);
  if (from._internal_has_attach_data()) {
    _this->_internal_set_attach_data(from._internal_attach_data());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMUsersStatRsp::CopyFrom(const IMUsersStatRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMUsersStatRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUsersStatRsp::IsInitialized() const {
  return true;
}

void IMUsersStatRsp::InternalSwap(IMUsersStatRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.user_stat_list_.InternalSwap(&other->_impl_.user_stat_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  swap(_impl_.user_id_, other->_impl_.user_id_);
}

std::string IMUsersStatRsp::GetTypeName() const {
  return "IM.Buddy.IMUsersStatRsp";
}


// ===================================================================

class IMChangeAvatarReq::_Internal {
 public:
  using HasBits = decltype(std::declval<IMChangeAvatarReq>()._impl_._has_bits_);
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IMChangeAvatarReq::IMChangeAvatarReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMChangeAvatarReq)
}
IMChangeAvatarReq::IMChangeAvatarReq(const IMChangeAvatarReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMChangeAvatarReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.avatar_url_){}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.avatar_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_avatar_url().empty()) {
    _this->_impl_.avatar_url_.Set(from._internal_avatar_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.user_id_ = from._impl_.user_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMChangeAvatarReq)
}

inline void IMChangeAvatarReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.avatar_url_){}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){0u}
  };
  _impl_.avatar_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IMChangeAvatarReq::~IMChangeAvatarReq() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMChangeAvatarReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMChangeAvatarReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.avatar_url_.Destroy();
  _impl_.attach_data_.Destroy();
}

void IMChangeAvatarReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMChangeAvatarReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMChangeAvatarReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.avatar_url_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  _impl_.user_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMChangeAvatarReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string avatar_url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_avatar_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMChangeAvatarReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMChangeAvatarReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // string avatar_url = 2;
  if (!this->_internal_avatar_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_avatar_url().data(), static_cast<int>(this->_internal_avatar_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IM.Buddy.IMChangeAvatarReq.avatar_url");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_avatar_url(), target);
  }

  // optional bytes attach_data = 20;
  if (_internal_has_attach_data()) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMChangeAvatarReq)
  return target;
}

size_t IMChangeAvatarReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMChangeAvatarReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string avatar_url = 2;
  if (!this->_internal_avatar_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar_url());
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMChangeAvatarReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMChangeAvatarReq*>(
      &from));
}

void IMChangeAvatarReq::MergeFrom(const IMChangeAvatarReq& from) {
  IMChangeAvatarReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMChangeAvatarReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_avatar_url().empty()) {
    _this->_internal_set_avatar_url(from._internal_avatar_url());
  }
  if (from._internal_has_attach_data()) {
    _this->_internal_set_attach_data(from._internal_attach_data());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMChangeAvatarReq::CopyFrom(const IMChangeAvatarReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMChangeAvatarReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMChangeAvatarReq::IsInitialized() const {
  return true;
}

void IMChangeAvatarReq::InternalSwap(IMChangeAvatarReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.avatar_url_, lhs_arena,
      &other->_impl_.avatar_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  swap(_impl_.user_id_, other->_impl_.user_id_);
}

std::string IMChangeAvatarReq::GetTypeName() const {
  return "IM.Buddy.IMChangeAvatarReq";
}


// ===================================================================

class IMChangeAvatarRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<IMChangeAvatarRsp>()._impl_._has_bits_);
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IMChangeAvatarRsp::IMChangeAvatarRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMChangeAvatarRsp)
}
IMChangeAvatarRsp::IMChangeAvatarRsp(const IMChangeAvatarRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMChangeAvatarRsp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.result_code_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.result_code_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.result_code_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMChangeAvatarRsp)
}

inline void IMChangeAvatarRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.result_code_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IMChangeAvatarRsp::~IMChangeAvatarRsp() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMChangeAvatarRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMChangeAvatarRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attach_data_.Destroy();
}

void IMChangeAvatarRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMChangeAvatarRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMChangeAvatarRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.result_code_) -
      reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.result_code_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMChangeAvatarRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 result_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.result_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMChangeAvatarRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMChangeAvatarRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // uint32 result_code = 2;
  if (this->_internal_result_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_result_code(), target);
  }

  // optional bytes attach_data = 20;
  if (_internal_has_attach_data()) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMChangeAvatarRsp)
  return target;
}

size_t IMChangeAvatarRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMChangeAvatarRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  // uint32 result_code = 2;
  if (this->_internal_result_code() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMChangeAvatarRsp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMChangeAvatarRsp*>(
      &from));
}

void IMChangeAvatarRsp::MergeFrom(const IMChangeAvatarRsp& from) {
  IMChangeAvatarRsp* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMChangeAvatarRsp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_attach_data()) {
    _this->_internal_set_attach_data(from._internal_attach_data());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_result_code() != 0) {
    _this->_internal_set_result_code(from._internal_result_code());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMChangeAvatarRsp::CopyFrom(const IMChangeAvatarRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMChangeAvatarRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMChangeAvatarRsp::IsInitialized() const {
  return true;
}

void IMChangeAvatarRsp::InternalSwap(IMChangeAvatarRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMChangeAvatarRsp, _impl_.result_code_)
      + sizeof(IMChangeAvatarRsp::_impl_.result_code_)
      - PROTOBUF_FIELD_OFFSET(IMChangeAvatarRsp, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string IMChangeAvatarRsp::GetTypeName() const {
  return "IM.Buddy.IMChangeAvatarRsp";
}


// ===================================================================

class IMPCLoginStatusNotify::_Internal {
 public:
};

IMPCLoginStatusNotify::IMPCLoginStatusNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMPCLoginStatusNotify)
}
IMPCLoginStatusNotify::IMPCLoginStatusNotify(const IMPCLoginStatusNotify& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMPCLoginStatusNotify* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_id_){}
    , decltype(_impl_.login_stat_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.login_stat_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.login_stat_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMPCLoginStatusNotify)
}

inline void IMPCLoginStatusNotify::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_id_){0u}
    , decltype(_impl_.login_stat_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

IMPCLoginStatusNotify::~IMPCLoginStatusNotify() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMPCLoginStatusNotify)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMPCLoginStatusNotify::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IMPCLoginStatusNotify::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMPCLoginStatusNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMPCLoginStatusNotify)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.login_stat_) -
      reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.login_stat_));
  _internal_metadata_.Clear<std::string>();
}

const char* IMPCLoginStatusNotify::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.UserStatType login_stat = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_login_stat(static_cast<::IM::BaseDefine::UserStatType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMPCLoginStatusNotify::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMPCLoginStatusNotify)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // .IM.BaseDefine.UserStatType login_stat = 2;
  if (this->_internal_login_stat() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_login_stat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMPCLoginStatusNotify)
  return target;
}

size_t IMPCLoginStatusNotify::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMPCLoginStatusNotify)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  // .IM.BaseDefine.UserStatType login_stat = 2;
  if (this->_internal_login_stat() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_login_stat());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMPCLoginStatusNotify::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMPCLoginStatusNotify*>(
      &from));
}

void IMPCLoginStatusNotify::MergeFrom(const IMPCLoginStatusNotify& from) {
  IMPCLoginStatusNotify* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMPCLoginStatusNotify)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_login_stat() != 0) {
    _this->_internal_set_login_stat(from._internal_login_stat());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMPCLoginStatusNotify::CopyFrom(const IMPCLoginStatusNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMPCLoginStatusNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMPCLoginStatusNotify::IsInitialized() const {
  return true;
}

void IMPCLoginStatusNotify::InternalSwap(IMPCLoginStatusNotify* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMPCLoginStatusNotify, _impl_.login_stat_)
      + sizeof(IMPCLoginStatusNotify::_impl_.login_stat_)
      - PROTOBUF_FIELD_OFFSET(IMPCLoginStatusNotify, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string IMPCLoginStatusNotify::GetTypeName() const {
  return "IM.Buddy.IMPCLoginStatusNotify";
}


// ===================================================================

class IMRemoveSessionNotify::_Internal {
 public:
};

IMRemoveSessionNotify::IMRemoveSessionNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMRemoveSessionNotify)
}
IMRemoveSessionNotify::IMRemoveSessionNotify(const IMRemoveSessionNotify& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMRemoveSessionNotify* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_id_){}
    , decltype(_impl_.session_type_){}
    , decltype(_impl_.session_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.session_id_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.session_id_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMRemoveSessionNotify)
}

inline void IMRemoveSessionNotify::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_id_){0u}
    , decltype(_impl_.session_type_){0}
    , decltype(_impl_.session_id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

IMRemoveSessionNotify::~IMRemoveSessionNotify() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMRemoveSessionNotify)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMRemoveSessionNotify::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IMRemoveSessionNotify::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMRemoveSessionNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMRemoveSessionNotify)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.session_id_) -
      reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.session_id_));
  _internal_metadata_.Clear<std::string>();
}

const char* IMRemoveSessionNotify::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IM.BaseDefine.SessionType session_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_session_type(static_cast<::IM::BaseDefine::SessionType>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 session_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMRemoveSessionNotify::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMRemoveSessionNotify)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // .IM.BaseDefine.SessionType session_type = 2;
  if (this->_internal_session_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_session_type(), target);
  }

  // uint32 session_id = 3;
  if (this->_internal_session_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_session_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMRemoveSessionNotify)
  return target;
}

size_t IMRemoveSessionNotify::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMRemoveSessionNotify)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  // .IM.BaseDefine.SessionType session_type = 2;
  if (this->_internal_session_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  // uint32 session_id = 3;
  if (this->_internal_session_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMRemoveSessionNotify::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMRemoveSessionNotify*>(
      &from));
}

void IMRemoveSessionNotify::MergeFrom(const IMRemoveSessionNotify& from) {
  IMRemoveSessionNotify* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMRemoveSessionNotify)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_session_type() != 0) {
    _this->_internal_set_session_type(from._internal_session_type());
  }
  if (from._internal_session_id() != 0) {
    _this->_internal_set_session_id(from._internal_session_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMRemoveSessionNotify::CopyFrom(const IMRemoveSessionNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMRemoveSessionNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRemoveSessionNotify::IsInitialized() const {
  return true;
}

void IMRemoveSessionNotify::InternalSwap(IMRemoveSessionNotify* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMRemoveSessionNotify, _impl_.session_id_)
      + sizeof(IMRemoveSessionNotify::_impl_.session_id_)
      - PROTOBUF_FIELD_OFFSET(IMRemoveSessionNotify, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string IMRemoveSessionNotify::GetTypeName() const {
  return "IM.Buddy.IMRemoveSessionNotify";
}


// ===================================================================

class IMDepartmentReq::_Internal {
 public:
  using HasBits = decltype(std::declval<IMDepartmentReq>()._impl_._has_bits_);
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IMDepartmentReq::IMDepartmentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMDepartmentReq)
}
IMDepartmentReq::IMDepartmentReq(const IMDepartmentReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMDepartmentReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.latest_update_time_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.latest_update_time_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.latest_update_time_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMDepartmentReq)
}

inline void IMDepartmentReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.latest_update_time_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IMDepartmentReq::~IMDepartmentReq() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMDepartmentReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMDepartmentReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attach_data_.Destroy();
}

void IMDepartmentReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMDepartmentReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMDepartmentReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.latest_update_time_) -
      reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.latest_update_time_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMDepartmentReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 latest_update_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.latest_update_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMDepartmentReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMDepartmentReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // uint32 latest_update_time = 2;
  if (this->_internal_latest_update_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_latest_update_time(), target);
  }

  // optional bytes attach_data = 20;
  if (_internal_has_attach_data()) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMDepartmentReq)
  return target;
}

size_t IMDepartmentReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMDepartmentReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  // uint32 latest_update_time = 2;
  if (this->_internal_latest_update_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_update_time());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMDepartmentReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMDepartmentReq*>(
      &from));
}

void IMDepartmentReq::MergeFrom(const IMDepartmentReq& from) {
  IMDepartmentReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMDepartmentReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_attach_data()) {
    _this->_internal_set_attach_data(from._internal_attach_data());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_latest_update_time() != 0) {
    _this->_internal_set_latest_update_time(from._internal_latest_update_time());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMDepartmentReq::CopyFrom(const IMDepartmentReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMDepartmentReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMDepartmentReq::IsInitialized() const {
  return true;
}

void IMDepartmentReq::InternalSwap(IMDepartmentReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMDepartmentReq, _impl_.latest_update_time_)
      + sizeof(IMDepartmentReq::_impl_.latest_update_time_)
      - PROTOBUF_FIELD_OFFSET(IMDepartmentReq, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string IMDepartmentReq::GetTypeName() const {
  return "IM.Buddy.IMDepartmentReq";
}


// ===================================================================

class IMDepartmentRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<IMDepartmentRsp>()._impl_._has_bits_);
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

void IMDepartmentRsp::clear_dept_list() {
  _impl_.dept_list_.Clear();
}
IMDepartmentRsp::IMDepartmentRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IM.Buddy.IMDepartmentRsp)
}
IMDepartmentRsp::IMDepartmentRsp(const IMDepartmentRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IMDepartmentRsp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dept_list_){from._impl_.dept_list_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.latest_update_time_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.latest_update_time_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.latest_update_time_));
  // @@protoc_insertion_point(copy_constructor:IM.Buddy.IMDepartmentRsp)
}

inline void IMDepartmentRsp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dept_list_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.latest_update_time_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IMDepartmentRsp::~IMDepartmentRsp() {
  // @@protoc_insertion_point(destructor:IM.Buddy.IMDepartmentRsp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IMDepartmentRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dept_list_.~RepeatedPtrField();
  _impl_.attach_data_.Destroy();
}

void IMDepartmentRsp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IMDepartmentRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Buddy.IMDepartmentRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dept_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.latest_update_time_) -
      reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.latest_update_time_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IMDepartmentRsp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 latest_update_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.latest_update_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .IM.BaseDefine.DepartInfo dept_list = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_dept_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IMDepartmentRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IM.Buddy.IMDepartmentRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // uint32 latest_update_time = 2;
  if (this->_internal_latest_update_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_latest_update_time(), target);
  }

  // repeated .IM.BaseDefine.DepartInfo dept_list = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dept_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_dept_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes attach_data = 20;
  if (_internal_has_attach_data()) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IM.Buddy.IMDepartmentRsp)
  return target;
}

size_t IMDepartmentRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Buddy.IMDepartmentRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IM.BaseDefine.DepartInfo dept_list = 3;
  total_size += 1UL * this->_internal_dept_list_size();
  for (const auto& msg : this->_impl_.dept_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // uint32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  // uint32 latest_update_time = 2;
  if (this->_internal_latest_update_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_update_time());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMDepartmentRsp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IMDepartmentRsp*>(
      &from));
}

void IMDepartmentRsp::MergeFrom(const IMDepartmentRsp& from) {
  IMDepartmentRsp* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:IM.Buddy.IMDepartmentRsp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dept_list_.MergeFrom(from._impl_.dept_list_);
  if (from._internal_has_attach_data()) {
    _this->_internal_set_attach_data(from._internal_attach_data());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_latest_update_time() != 0) {
    _this->_internal_set_latest_update_time(from._internal_latest_update_time());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IMDepartmentRsp::CopyFrom(const IMDepartmentRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Buddy.IMDepartmentRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMDepartmentRsp::IsInitialized() const {
  return true;
}

void IMDepartmentRsp::InternalSwap(IMDepartmentRsp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.dept_list_.InternalSwap(&other->_impl_.dept_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMDepartmentRsp, _impl_.latest_update_time_)
      + sizeof(IMDepartmentRsp::_impl_.latest_update_time_)
      - PROTOBUF_FIELD_OFFSET(IMDepartmentRsp, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string IMDepartmentRsp::GetTypeName() const {
  return "IM.Buddy.IMDepartmentRsp";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Buddy
}  // namespace IM
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMRecentContactSessionReq*
Arena::CreateMaybeMessage< ::IM::Buddy::IMRecentContactSessionReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMRecentContactSessionReq >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMRecentContactSessionRsp*
Arena::CreateMaybeMessage< ::IM::Buddy::IMRecentContactSessionRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMRecentContactSessionRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMUserStatNotify*
Arena::CreateMaybeMessage< ::IM::Buddy::IMUserStatNotify >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMUserStatNotify >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMUsersInfoReq*
Arena::CreateMaybeMessage< ::IM::Buddy::IMUsersInfoReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMUsersInfoReq >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMUsersInfoRsp*
Arena::CreateMaybeMessage< ::IM::Buddy::IMUsersInfoRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMUsersInfoRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMRemoveSessionReq*
Arena::CreateMaybeMessage< ::IM::Buddy::IMRemoveSessionReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMRemoveSessionReq >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMRemoveSessionRsp*
Arena::CreateMaybeMessage< ::IM::Buddy::IMRemoveSessionRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMRemoveSessionRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMAllUserReq*
Arena::CreateMaybeMessage< ::IM::Buddy::IMAllUserReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMAllUserReq >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMAllUserRsp*
Arena::CreateMaybeMessage< ::IM::Buddy::IMAllUserRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMAllUserRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMUsersStatReq*
Arena::CreateMaybeMessage< ::IM::Buddy::IMUsersStatReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMUsersStatReq >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMUsersStatRsp*
Arena::CreateMaybeMessage< ::IM::Buddy::IMUsersStatRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMUsersStatRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMChangeAvatarReq*
Arena::CreateMaybeMessage< ::IM::Buddy::IMChangeAvatarReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMChangeAvatarReq >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMChangeAvatarRsp*
Arena::CreateMaybeMessage< ::IM::Buddy::IMChangeAvatarRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMChangeAvatarRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMPCLoginStatusNotify*
Arena::CreateMaybeMessage< ::IM::Buddy::IMPCLoginStatusNotify >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMPCLoginStatusNotify >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMRemoveSessionNotify*
Arena::CreateMaybeMessage< ::IM::Buddy::IMRemoveSessionNotify >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMRemoveSessionNotify >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMDepartmentReq*
Arena::CreateMaybeMessage< ::IM::Buddy::IMDepartmentReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMDepartmentReq >(arena);
}
template<> PROTOBUF_NOINLINE ::IM::Buddy::IMDepartmentRsp*
Arena::CreateMaybeMessage< ::IM::Buddy::IMDepartmentRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IM::Buddy::IMDepartmentRsp >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
